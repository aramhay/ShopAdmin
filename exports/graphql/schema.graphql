input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type Beauty {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
}

type BeautyConnection {
  values: [Beauty]
  groupBy: BeautyGroupBy
  aggregate: BeautyAggregator
}

type BeautyAggregator {
  count: Int
  totalCount: Int
}

type BeautyGroupBy {
  id: [BeautyConnectionId]
  created_at: [BeautyConnectionCreated_at]
  updated_at: [BeautyConnectionUpdated_at]
  productId: [BeautyConnectionProductId]
  images: [BeautyConnectionImages]
  New_Date_Limit: [BeautyConnectionNew_Date_Limit]
  limited_edition: [BeautyConnectionLimited_edition]
  brand: [BeautyConnectionBrand]
  kind: [BeautyConnectionKind]
  name: [BeautyConnectionName]
  price: [BeautyConnectionPrice]
  clean_product: [BeautyConnectionClean_product]
  published_at: [BeautyConnectionPublished_at]
}

type BeautyConnectionId {
  key: ID
  connection: BeautyConnection
}

type BeautyConnectionCreated_at {
  key: DateTime
  connection: BeautyConnection
}

type BeautyConnectionUpdated_at {
  key: DateTime
  connection: BeautyConnection
}

type BeautyConnectionProductId {
  key: ID
  connection: BeautyConnection
}

type BeautyConnectionImages {
  key: String
  connection: BeautyConnection
}

type BeautyConnectionNew_Date_Limit {
  key: ID
  connection: BeautyConnection
}

type BeautyConnectionLimited_edition {
  key: Boolean
  connection: BeautyConnection
}

type BeautyConnectionBrand {
  key: String
  connection: BeautyConnection
}

type BeautyConnectionKind {
  key: String
  connection: BeautyConnection
}

type BeautyConnectionName {
  key: String
  connection: BeautyConnection
}

type BeautyConnectionPrice {
  key: ID
  connection: BeautyConnection
}

type BeautyConnectionClean_product {
  key: Boolean
  connection: BeautyConnection
}

type BeautyConnectionPublished_at {
  key: DateTime
  connection: BeautyConnection
}

input BeautyInput {
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editBeautyInput {
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createBeautyInput {
  data: BeautyInput
}

type createBeautyPayload {
  beauty: Beauty
}

input updateBeautyInput {
  where: InputID
  data: editBeautyInput
}

type updateBeautyPayload {
  beauty: Beauty
}

input deleteBeautyInput {
  where: InputID
}

type deleteBeautyPayload {
  beauty: Beauty
}

type Bookmark {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  users_permissions_user: UsersPermissionsUser
  video: Videos
  published_at: DateTime
}

type BookmarkConnection {
  values: [Bookmark]
  groupBy: BookmarkGroupBy
  aggregate: BookmarkAggregator
}

type BookmarkAggregator {
  count: Int
  totalCount: Int
}

type BookmarkGroupBy {
  id: [BookmarkConnectionId]
  created_at: [BookmarkConnectionCreated_at]
  updated_at: [BookmarkConnectionUpdated_at]
  users_permissions_user: [BookmarkConnectionUsers_permissions_user]
  video: [BookmarkConnectionVideo]
  published_at: [BookmarkConnectionPublished_at]
}

type BookmarkConnectionId {
  key: ID
  connection: BookmarkConnection
}

type BookmarkConnectionCreated_at {
  key: DateTime
  connection: BookmarkConnection
}

type BookmarkConnectionUpdated_at {
  key: DateTime
  connection: BookmarkConnection
}

type BookmarkConnectionUsers_permissions_user {
  key: ID
  connection: BookmarkConnection
}

type BookmarkConnectionVideo {
  key: ID
  connection: BookmarkConnection
}

type BookmarkConnectionPublished_at {
  key: DateTime
  connection: BookmarkConnection
}

input BookmarkInput {
  users_permissions_user: ID
  video: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editBookmarkInput {
  users_permissions_user: ID
  video: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createBookmarkInput {
  data: BookmarkInput
}

type createBookmarkPayload {
  bookmark: Bookmark
}

input updateBookmarkInput {
  where: InputID
  data: editBookmarkInput
}

type updateBookmarkPayload {
  bookmark: Bookmark
}

input deleteBookmarkInput {
  where: InputID
}

type deleteBookmarkPayload {
  bookmark: Bookmark
}

type Category {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  CategoryName: String!
  published_at: DateTime
  sub_categories(sort: String, limit: Int, start: Int, where: JSON): [SubCategory]
}

type CategoryConnection {
  values: [Category]
  groupBy: CategoryGroupBy
  aggregate: CategoryAggregator
}

type CategoryAggregator {
  count: Int
  totalCount: Int
}

type CategoryGroupBy {
  id: [CategoryConnectionId]
  created_at: [CategoryConnectionCreated_at]
  updated_at: [CategoryConnectionUpdated_at]
  CategoryName: [CategoryConnectionCategoryName]
  published_at: [CategoryConnectionPublished_at]
}

type CategoryConnectionId {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionCreated_at {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionUpdated_at {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionCategoryName {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionPublished_at {
  key: DateTime
  connection: CategoryConnection
}

input CategoryInput {
  CategoryName: String!
  sub_categories: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCategoryInput {
  CategoryName: String
  sub_categories: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCategoryInput {
  data: CategoryInput
}

type createCategoryPayload {
  category: Category
}

input updateCategoryInput {
  where: InputID
  data: editCategoryInput
}

type updateCategoryPayload {
  category: Category
}

input deleteCategoryInput {
  where: InputID
}

type deleteCategoryPayload {
  category: Category
}

enum ENUM_COLLECTIONSHOP_POSITION {
  HomePageLeft
  HomePageRight
  HerrenPageLeft
  HerrenPageRight
}

type CollectionShop {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  url: String
  images: UploadFile
  Link_text: String
  position: ENUM_COLLECTIONSHOP_POSITION!
  published_at: DateTime
}

type CollectionShopConnection {
  values: [CollectionShop]
  groupBy: CollectionShopGroupBy
  aggregate: CollectionShopAggregator
}

type CollectionShopAggregator {
  count: Int
  totalCount: Int
}

type CollectionShopGroupBy {
  id: [CollectionShopConnectionId]
  created_at: [CollectionShopConnectionCreated_at]
  updated_at: [CollectionShopConnectionUpdated_at]
  header: [CollectionShopConnectionHeader]
  title: [CollectionShopConnectionTitle]
  url: [CollectionShopConnectionUrl]
  images: [CollectionShopConnectionImages]
  Link_text: [CollectionShopConnectionLink_text]
  position: [CollectionShopConnectionPosition]
  published_at: [CollectionShopConnectionPublished_at]
}

type CollectionShopConnectionId {
  key: ID
  connection: CollectionShopConnection
}

type CollectionShopConnectionCreated_at {
  key: DateTime
  connection: CollectionShopConnection
}

type CollectionShopConnectionUpdated_at {
  key: DateTime
  connection: CollectionShopConnection
}

type CollectionShopConnectionHeader {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionTitle {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionUrl {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionImages {
  key: ID
  connection: CollectionShopConnection
}

type CollectionShopConnectionLink_text {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionPosition {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionPublished_at {
  key: DateTime
  connection: CollectionShopConnection
}

input CollectionShopInput {
  header: String
  title: String
  url: String
  images: ID
  Link_text: String
  position: ENUM_COLLECTIONSHOP_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCollectionShopInput {
  header: String
  title: String
  url: String
  images: ID
  Link_text: String
  position: ENUM_COLLECTIONSHOP_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCollectionShopInput {
  data: CollectionShopInput
}

type createCollectionShopPayload {
  collectionShop: CollectionShop
}

input updateCollectionShopInput {
  where: InputID
  data: editCollectionShopInput
}

type updateCollectionShopPayload {
  collectionShop: CollectionShop
}

input deleteCollectionShopInput {
  where: InputID
}

type deleteCollectionShopPayload {
  collectionShop: CollectionShop
}

type ContactDetails {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  email: String
  phone_number: String
  published_at: DateTime
}

type ContactDetailsConnection {
  values: [ContactDetails]
  groupBy: ContactDetailsGroupBy
  aggregate: ContactDetailsAggregator
}

type ContactDetailsAggregator {
  count: Int
  totalCount: Int
}

type ContactDetailsGroupBy {
  id: [ContactDetailsConnectionId]
  created_at: [ContactDetailsConnectionCreated_at]
  updated_at: [ContactDetailsConnectionUpdated_at]
  email: [ContactDetailsConnectionEmail]
  phone_number: [ContactDetailsConnectionPhone_number]
  published_at: [ContactDetailsConnectionPublished_at]
}

type ContactDetailsConnectionId {
  key: ID
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionCreated_at {
  key: DateTime
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionUpdated_at {
  key: DateTime
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionEmail {
  key: String
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionPhone_number {
  key: String
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionPublished_at {
  key: DateTime
  connection: ContactDetailsConnection
}

input ContactDetailInput {
  email: String
  phone_number: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editContactDetailInput {
  email: String
  phone_number: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createContactDetailInput {
  data: ContactDetailInput
}

type createContactDetailPayload {
  contactDetail: ContactDetails
}

input updateContactDetailInput {
  where: InputID
  data: editContactDetailInput
}

type updateContactDetailPayload {
  contactDetail: ContactDetails
}

input deleteContactDetailInput {
  where: InputID
}

type deleteContactDetailPayload {
  contactDetail: ContactDetails
}

type Contact {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  value: String
  published_at: DateTime
}

type ContactConnection {
  values: [Contact]
  groupBy: ContactGroupBy
  aggregate: ContactAggregator
}

type ContactAggregator {
  count: Int
  totalCount: Int
}

type ContactGroupBy {
  id: [ContactConnectionId]
  created_at: [ContactConnectionCreated_at]
  updated_at: [ContactConnectionUpdated_at]
  title: [ContactConnectionTitle]
  value: [ContactConnectionValue]
  published_at: [ContactConnectionPublished_at]
}

type ContactConnectionId {
  key: ID
  connection: ContactConnection
}

type ContactConnectionCreated_at {
  key: DateTime
  connection: ContactConnection
}

type ContactConnectionUpdated_at {
  key: DateTime
  connection: ContactConnection
}

type ContactConnectionTitle {
  key: String
  connection: ContactConnection
}

type ContactConnectionValue {
  key: String
  connection: ContactConnection
}

type ContactConnectionPublished_at {
  key: DateTime
  connection: ContactConnection
}

input ContactInput {
  title: String
  value: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editContactInput {
  title: String
  value: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createContactInput {
  data: ContactInput
}

type createContactPayload {
  contact: Contact
}

input updateContactInput {
  where: InputID
  data: editContactInput
}

type updateContactPayload {
  contact: Contact
}

input deleteContactInput {
  where: InputID
}

type deleteContactPayload {
  contact: Contact
}

enum ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT {
  prozentual
  absolut
  Stuck
  Versand
}

type DiscountCodes {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  Description: String
  status_voucher: Boolean
  unique_multiple: Boolean
  multiple_redemptions: Boolean
  one_redemption: Boolean
  redeem_until_usedup: JSON
  single_redemption: JSON
  Minimum_order_value: Long
  valid_from_date_time: DateTime
  Valid_to_date_time: DateTime
  code_character_length: Long
  amount_discount: Long
  type_of_discount: ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT
  published_at: DateTime
  products(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type DiscountCodesConnection {
  values: [DiscountCodes]
  groupBy: DiscountCodesGroupBy
  aggregate: DiscountCodesAggregator
}

type DiscountCodesAggregator {
  count: Int
  totalCount: Int
}

type DiscountCodesGroupBy {
  id: [DiscountCodesConnectionId]
  created_at: [DiscountCodesConnectionCreated_at]
  updated_at: [DiscountCodesConnectionUpdated_at]
  Name: [DiscountCodesConnectionName]
  Description: [DiscountCodesConnectionDescription]
  status_voucher: [DiscountCodesConnectionStatus_voucher]
  unique_multiple: [DiscountCodesConnectionUnique_multiple]
  multiple_redemptions: [DiscountCodesConnectionMultiple_redemptions]
  one_redemption: [DiscountCodesConnectionOne_redemption]
  redeem_until_usedup: [DiscountCodesConnectionRedeem_until_usedup]
  single_redemption: [DiscountCodesConnectionSingle_redemption]
  Minimum_order_value: [DiscountCodesConnectionMinimum_order_value]
  valid_from_date_time: [DiscountCodesConnectionValid_from_date_time]
  Valid_to_date_time: [DiscountCodesConnectionValid_to_date_time]
  code_character_length: [DiscountCodesConnectionCode_character_length]
  amount_discount: [DiscountCodesConnectionAmount_discount]
  type_of_discount: [DiscountCodesConnectionType_of_discount]
  published_at: [DiscountCodesConnectionPublished_at]
}

type DiscountCodesConnectionId {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionCreated_at {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionUpdated_at {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionName {
  key: String
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionDescription {
  key: String
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionStatus_voucher {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionUnique_multiple {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionMultiple_redemptions {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionOne_redemption {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionRedeem_until_usedup {
  key: JSON
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionSingle_redemption {
  key: JSON
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionMinimum_order_value {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionValid_from_date_time {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionValid_to_date_time {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionCode_character_length {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionAmount_discount {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionType_of_discount {
  key: String
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionPublished_at {
  key: DateTime
  connection: DiscountCodesConnection
}

input DiscountCodeInput {
  Name: String
  Description: String
  status_voucher: Boolean
  unique_multiple: Boolean
  multiple_redemptions: Boolean
  one_redemption: Boolean
  redeem_until_usedup: JSON
  single_redemption: JSON
  Minimum_order_value: Long
  valid_from_date_time: DateTime
  Valid_to_date_time: DateTime
  code_character_length: Long
  amount_discount: Long
  type_of_discount: ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDiscountCodeInput {
  Name: String
  Description: String
  status_voucher: Boolean
  unique_multiple: Boolean
  multiple_redemptions: Boolean
  one_redemption: Boolean
  redeem_until_usedup: JSON
  single_redemption: JSON
  Minimum_order_value: Long
  valid_from_date_time: DateTime
  Valid_to_date_time: DateTime
  code_character_length: Long
  amount_discount: Long
  type_of_discount: ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDiscountCodeInput {
  data: DiscountCodeInput
}

type createDiscountCodePayload {
  discountCode: DiscountCodes
}

input updateDiscountCodeInput {
  where: InputID
  data: editDiscountCodeInput
}

type updateDiscountCodePayload {
  discountCode: DiscountCodes
}

input deleteDiscountCodeInput {
  where: InputID
}

type deleteDiscountCodePayload {
  discountCode: DiscountCodes
}

type Discount {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  discount: Float
  minprice: Float
  published_at: DateTime
}

input DiscountInput {
  discount: Float
  minprice: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDiscountInput {
  discount: Float
  minprice: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateDiscountInput {
  data: editDiscountInput
}

type updateDiscountPayload {
  discount: Discount
}

type deleteDiscountPayload {
  discount: Discount
}

type DpabStore {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  value_1: String
  value_2: String
  published_at: DateTime
}

type DpabStoreConnection {
  values: [DpabStore]
  groupBy: DpabStoreGroupBy
  aggregate: DpabStoreAggregator
}

type DpabStoreAggregator {
  count: Int
  totalCount: Int
}

type DpabStoreGroupBy {
  id: [DpabStoreConnectionId]
  created_at: [DpabStoreConnectionCreated_at]
  updated_at: [DpabStoreConnectionUpdated_at]
  title: [DpabStoreConnectionTitle]
  value_1: [DpabStoreConnectionValue_1]
  value_2: [DpabStoreConnectionValue_2]
  published_at: [DpabStoreConnectionPublished_at]
}

type DpabStoreConnectionId {
  key: ID
  connection: DpabStoreConnection
}

type DpabStoreConnectionCreated_at {
  key: DateTime
  connection: DpabStoreConnection
}

type DpabStoreConnectionUpdated_at {
  key: DateTime
  connection: DpabStoreConnection
}

type DpabStoreConnectionTitle {
  key: String
  connection: DpabStoreConnection
}

type DpabStoreConnectionValue_1 {
  key: String
  connection: DpabStoreConnection
}

type DpabStoreConnectionValue_2 {
  key: String
  connection: DpabStoreConnection
}

type DpabStoreConnectionPublished_at {
  key: DateTime
  connection: DpabStoreConnection
}

input DpabStoreInput {
  title: String
  value_1: String
  value_2: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDpabStoreInput {
  title: String
  value_1: String
  value_2: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDpabStoreInput {
  data: DpabStoreInput
}

type createDpabStorePayload {
  dpabStore: DpabStore
}

input updateDpabStoreInput {
  where: InputID
  data: editDpabStoreInput
}

type updateDpabStorePayload {
  dpabStore: DpabStore
}

input deleteDpabStoreInput {
  where: InputID
}

type deleteDpabStorePayload {
  dpabStore: DpabStore
}

enum ENUM_EIGHTPRODUCTS_POSITION {
  HerrenPageOne
  HerrenPageTwo
}

type EightProducts {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  position: ENUM_EIGHTPRODUCTS_POSITION!
  published_at: DateTime
  beauties(sort: String, limit: Int, start: Int, where: JSON): [Beauty]
  interieurs(sort: String, limit: Int, start: Int, where: JSON): [Interieur]
  parfums(sort: String, limit: Int, start: Int, where: JSON): [Parfums]
}

type EightProductsConnection {
  values: [EightProducts]
  groupBy: EightProductsGroupBy
  aggregate: EightProductsAggregator
}

type EightProductsAggregator {
  count: Int
  totalCount: Int
}

type EightProductsGroupBy {
  id: [EightProductsConnectionId]
  created_at: [EightProductsConnectionCreated_at]
  updated_at: [EightProductsConnectionUpdated_at]
  position: [EightProductsConnectionPosition]
  published_at: [EightProductsConnectionPublished_at]
}

type EightProductsConnectionId {
  key: ID
  connection: EightProductsConnection
}

type EightProductsConnectionCreated_at {
  key: DateTime
  connection: EightProductsConnection
}

type EightProductsConnectionUpdated_at {
  key: DateTime
  connection: EightProductsConnection
}

type EightProductsConnectionPosition {
  key: String
  connection: EightProductsConnection
}

type EightProductsConnectionPublished_at {
  key: DateTime
  connection: EightProductsConnection
}

input EightProductInput {
  position: ENUM_EIGHTPRODUCTS_POSITION
  beauties: [ID]
  interieurs: [ID]
  parfums: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editEightProductInput {
  position: ENUM_EIGHTPRODUCTS_POSITION
  beauties: [ID]
  interieurs: [ID]
  parfums: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createEightProductInput {
  data: EightProductInput
}

type createEightProductPayload {
  eightProduct: EightProducts
}

input updateEightProductInput {
  where: InputID
  data: editEightProductInput
}

type updateEightProductPayload {
  eightProduct: EightProducts
}

input deleteEightProductInput {
  where: InputID
}

type deleteEightProductPayload {
  eightProduct: EightProducts
}

type FavoriteProduct {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  users_permissions_user: UsersPermissionsUser
  product: Products
  published_at: DateTime
}

type FavoriteProductConnection {
  values: [FavoriteProduct]
  groupBy: FavoriteProductGroupBy
  aggregate: FavoriteProductAggregator
}

type FavoriteProductAggregator {
  count: Int
  totalCount: Int
}

type FavoriteProductGroupBy {
  id: [FavoriteProductConnectionId]
  created_at: [FavoriteProductConnectionCreated_at]
  updated_at: [FavoriteProductConnectionUpdated_at]
  users_permissions_user: [FavoriteProductConnectionUsers_permissions_user]
  product: [FavoriteProductConnectionProduct]
  published_at: [FavoriteProductConnectionPublished_at]
}

type FavoriteProductConnectionId {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionCreated_at {
  key: DateTime
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionUpdated_at {
  key: DateTime
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionUsers_permissions_user {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionProduct {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionPublished_at {
  key: DateTime
  connection: FavoriteProductConnection
}

input FavoriteProductInput {
  users_permissions_user: ID
  product: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editFavoriteProductInput {
  users_permissions_user: ID
  product: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createFavoriteProductInput {
  data: FavoriteProductInput
}

type createFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

input updateFavoriteProductInput {
  where: InputID
  data: editFavoriteProductInput
}

type updateFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

input deleteFavoriteProductInput {
  where: InputID
}

type deleteFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

type FourIcons {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  text: String
  published_at: DateTime
}

type FourIconsConnection {
  values: [FourIcons]
  groupBy: FourIconsGroupBy
  aggregate: FourIconsAggregator
}

type FourIconsAggregator {
  count: Int
  totalCount: Int
}

type FourIconsGroupBy {
  id: [FourIconsConnectionId]
  created_at: [FourIconsConnectionCreated_at]
  updated_at: [FourIconsConnectionUpdated_at]
  header: [FourIconsConnectionHeader]
  text: [FourIconsConnectionText]
  published_at: [FourIconsConnectionPublished_at]
}

type FourIconsConnectionId {
  key: ID
  connection: FourIconsConnection
}

type FourIconsConnectionCreated_at {
  key: DateTime
  connection: FourIconsConnection
}

type FourIconsConnectionUpdated_at {
  key: DateTime
  connection: FourIconsConnection
}

type FourIconsConnectionHeader {
  key: String
  connection: FourIconsConnection
}

type FourIconsConnectionText {
  key: String
  connection: FourIconsConnection
}

type FourIconsConnectionPublished_at {
  key: DateTime
  connection: FourIconsConnection
}

input FourIconInput {
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editFourIconInput {
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createFourIconInput {
  data: FourIconInput
}

type createFourIconPayload {
  fourIcon: FourIcons
}

input updateFourIconInput {
  where: InputID
  data: editFourIconInput
}

type updateFourIconPayload {
  fourIcon: FourIcons
}

input deleteFourIconInput {
  where: InputID
}

type deleteFourIconPayload {
  fourIcon: FourIcons
}

enum ENUM_FOURPRODUCTS_POSITION {
  HomePage
  ProductPage
}

type FourProducts {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  position: ENUM_FOURPRODUCTS_POSITION!
  published_at: DateTime
  parfums(sort: String, limit: Int, start: Int, where: JSON): [Parfums]
  beauties(sort: String, limit: Int, start: Int, where: JSON): [Beauty]
  interieurs(sort: String, limit: Int, start: Int, where: JSON): [Interieur]
}

type FourProductsConnection {
  values: [FourProducts]
  groupBy: FourProductsGroupBy
  aggregate: FourProductsAggregator
}

type FourProductsAggregator {
  count: Int
  totalCount: Int
}

type FourProductsGroupBy {
  id: [FourProductsConnectionId]
  created_at: [FourProductsConnectionCreated_at]
  updated_at: [FourProductsConnectionUpdated_at]
  position: [FourProductsConnectionPosition]
  published_at: [FourProductsConnectionPublished_at]
}

type FourProductsConnectionId {
  key: ID
  connection: FourProductsConnection
}

type FourProductsConnectionCreated_at {
  key: DateTime
  connection: FourProductsConnection
}

type FourProductsConnectionUpdated_at {
  key: DateTime
  connection: FourProductsConnection
}

type FourProductsConnectionPosition {
  key: String
  connection: FourProductsConnection
}

type FourProductsConnectionPublished_at {
  key: DateTime
  connection: FourProductsConnection
}

input FourProductInput {
  position: ENUM_FOURPRODUCTS_POSITION
  parfums: [ID]
  beauties: [ID]
  interieurs: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editFourProductInput {
  position: ENUM_FOURPRODUCTS_POSITION
  parfums: [ID]
  beauties: [ID]
  interieurs: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createFourProductInput {
  data: FourProductInput
}

type createFourProductPayload {
  fourProduct: FourProducts
}

input updateFourProductInput {
  where: InputID
  data: editFourProductInput
}

type updateFourProductPayload {
  fourProduct: FourProducts
}

input deleteFourProductInput {
  where: InputID
}

type deleteFourProductPayload {
  fourProduct: FourProducts
}

enum ENUM_GIFTWRAP_SECURE {
  One
}

type GiftWrap {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  price: Long
  Name: String
  Text: String
  secure: ENUM_GIFTWRAP_SECURE!
  published_at: DateTime
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type GiftWrapConnection {
  values: [GiftWrap]
  groupBy: GiftWrapGroupBy
  aggregate: GiftWrapAggregator
}

type GiftWrapAggregator {
  count: Int
  totalCount: Int
}

type GiftWrapGroupBy {
  id: [GiftWrapConnectionId]
  created_at: [GiftWrapConnectionCreated_at]
  updated_at: [GiftWrapConnectionUpdated_at]
  price: [GiftWrapConnectionPrice]
  Name: [GiftWrapConnectionName]
  Text: [GiftWrapConnectionText]
  secure: [GiftWrapConnectionSecure]
  published_at: [GiftWrapConnectionPublished_at]
}

type GiftWrapConnectionId {
  key: ID
  connection: GiftWrapConnection
}

type GiftWrapConnectionCreated_at {
  key: DateTime
  connection: GiftWrapConnection
}

type GiftWrapConnectionUpdated_at {
  key: DateTime
  connection: GiftWrapConnection
}

type GiftWrapConnectionPrice {
  key: ID
  connection: GiftWrapConnection
}

type GiftWrapConnectionName {
  key: String
  connection: GiftWrapConnection
}

type GiftWrapConnectionText {
  key: String
  connection: GiftWrapConnection
}

type GiftWrapConnectionSecure {
  key: String
  connection: GiftWrapConnection
}

type GiftWrapConnectionPublished_at {
  key: DateTime
  connection: GiftWrapConnection
}

input GiftWrapInput {
  images: [ID]
  price: Long
  Name: String
  Text: String
  secure: ENUM_GIFTWRAP_SECURE
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editGiftWrapInput {
  images: [ID]
  price: Long
  Name: String
  Text: String
  secure: ENUM_GIFTWRAP_SECURE
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createGiftWrapInput {
  data: GiftWrapInput
}

type createGiftWrapPayload {
  giftWrap: GiftWrap
}

input updateGiftWrapInput {
  where: InputID
  data: editGiftWrapInput
}

type updateGiftWrapPayload {
  giftWrap: GiftWrap
}

input deleteGiftWrapInput {
  where: InputID
}

type deleteGiftWrapPayload {
  giftWrap: GiftWrap
}

enum ENUM_INSPIRATION_POSITION {
  HomePageOne
  HomePageTwo
  HomePageThre
  HerrenPageOne
  HerrenPageTwo
  HerrenPageThre
}

type Inspiration {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  text: String
  button_text: String
  url: String
  images: UploadFile
  image_header: String
  image_title: String
  position: ENUM_INSPIRATION_POSITION!
  published_at: DateTime
}

type InspirationConnection {
  values: [Inspiration]
  groupBy: InspirationGroupBy
  aggregate: InspirationAggregator
}

type InspirationAggregator {
  count: Int
  totalCount: Int
}

type InspirationGroupBy {
  id: [InspirationConnectionId]
  created_at: [InspirationConnectionCreated_at]
  updated_at: [InspirationConnectionUpdated_at]
  header: [InspirationConnectionHeader]
  title: [InspirationConnectionTitle]
  text: [InspirationConnectionText]
  button_text: [InspirationConnectionButton_text]
  url: [InspirationConnectionUrl]
  images: [InspirationConnectionImages]
  image_header: [InspirationConnectionImage_header]
  image_title: [InspirationConnectionImage_title]
  position: [InspirationConnectionPosition]
  published_at: [InspirationConnectionPublished_at]
}

type InspirationConnectionId {
  key: ID
  connection: InspirationConnection
}

type InspirationConnectionCreated_at {
  key: DateTime
  connection: InspirationConnection
}

type InspirationConnectionUpdated_at {
  key: DateTime
  connection: InspirationConnection
}

type InspirationConnectionHeader {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionTitle {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionText {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionButton_text {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionUrl {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionImages {
  key: ID
  connection: InspirationConnection
}

type InspirationConnectionImage_header {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionImage_title {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionPosition {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionPublished_at {
  key: DateTime
  connection: InspirationConnection
}

input InspirationInput {
  header: String
  title: String
  text: String
  button_text: String
  url: String
  images: ID
  image_header: String
  image_title: String
  position: ENUM_INSPIRATION_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editInspirationInput {
  header: String
  title: String
  text: String
  button_text: String
  url: String
  images: ID
  image_header: String
  image_title: String
  position: ENUM_INSPIRATION_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createInspirationInput {
  data: InspirationInput
}

type createInspirationPayload {
  inspiration: Inspiration
}

input updateInspirationInput {
  where: InputID
  data: editInspirationInput
}

type updateInspirationPayload {
  inspiration: Inspiration
}

input deleteInspirationInput {
  where: InputID
}

type deleteInspirationPayload {
  inspiration: Inspiration
}

type Interieur {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
}

type InterieurConnection {
  values: [Interieur]
  groupBy: InterieurGroupBy
  aggregate: InterieurAggregator
}

type InterieurAggregator {
  count: Int
  totalCount: Int
}

type InterieurGroupBy {
  id: [InterieurConnectionId]
  created_at: [InterieurConnectionCreated_at]
  updated_at: [InterieurConnectionUpdated_at]
  productId: [InterieurConnectionProductId]
  images: [InterieurConnectionImages]
  New_Date_Limit: [InterieurConnectionNew_Date_Limit]
  limited_edition: [InterieurConnectionLimited_edition]
  brand: [InterieurConnectionBrand]
  kind: [InterieurConnectionKind]
  name: [InterieurConnectionName]
  price: [InterieurConnectionPrice]
  clean_product: [InterieurConnectionClean_product]
  published_at: [InterieurConnectionPublished_at]
}

type InterieurConnectionId {
  key: ID
  connection: InterieurConnection
}

type InterieurConnectionCreated_at {
  key: DateTime
  connection: InterieurConnection
}

type InterieurConnectionUpdated_at {
  key: DateTime
  connection: InterieurConnection
}

type InterieurConnectionProductId {
  key: ID
  connection: InterieurConnection
}

type InterieurConnectionImages {
  key: String
  connection: InterieurConnection
}

type InterieurConnectionNew_Date_Limit {
  key: ID
  connection: InterieurConnection
}

type InterieurConnectionLimited_edition {
  key: Boolean
  connection: InterieurConnection
}

type InterieurConnectionBrand {
  key: String
  connection: InterieurConnection
}

type InterieurConnectionKind {
  key: String
  connection: InterieurConnection
}

type InterieurConnectionName {
  key: String
  connection: InterieurConnection
}

type InterieurConnectionPrice {
  key: ID
  connection: InterieurConnection
}

type InterieurConnectionClean_product {
  key: Boolean
  connection: InterieurConnection
}

type InterieurConnectionPublished_at {
  key: DateTime
  connection: InterieurConnection
}

input InterieurInput {
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editInterieurInput {
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createInterieurInput {
  data: InterieurInput
}

type createInterieurPayload {
  interieur: Interieur
}

input updateInterieurInput {
  where: InputID
  data: editInterieurInput
}

type updateInterieurPayload {
  interieur: Interieur
}

input deleteInterieurInput {
  where: InputID
}

type deleteInterieurPayload {
  interieur: Interieur
}

enum ENUM_MAGAZINPRESENTATION_POSITION {
  right
  left
  center
  full
}

type MagazinPresentation {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  images_1: UploadFile
  text_1: String
  text_2: String
  images_2: UploadFile
  position: ENUM_MAGAZINPRESENTATION_POSITION
  published_at: DateTime
  products(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type MagazinPresentationConnection {
  values: [MagazinPresentation]
  groupBy: MagazinPresentationGroupBy
  aggregate: MagazinPresentationAggregator
}

type MagazinPresentationAggregator {
  count: Int
  totalCount: Int
}

type MagazinPresentationGroupBy {
  id: [MagazinPresentationConnectionId]
  created_at: [MagazinPresentationConnectionCreated_at]
  updated_at: [MagazinPresentationConnectionUpdated_at]
  images_1: [MagazinPresentationConnectionImages_1]
  text_1: [MagazinPresentationConnectionText_1]
  text_2: [MagazinPresentationConnectionText_2]
  images_2: [MagazinPresentationConnectionImages_2]
  position: [MagazinPresentationConnectionPosition]
  published_at: [MagazinPresentationConnectionPublished_at]
}

type MagazinPresentationConnectionId {
  key: ID
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionCreated_at {
  key: DateTime
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionUpdated_at {
  key: DateTime
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionImages_1 {
  key: ID
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionText_1 {
  key: String
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionText_2 {
  key: String
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionImages_2 {
  key: ID
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionPosition {
  key: String
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionPublished_at {
  key: DateTime
  connection: MagazinPresentationConnection
}

input MagazinPresentationInput {
  images_1: ID
  text_1: String
  text_2: String
  images_2: ID
  position: ENUM_MAGAZINPRESENTATION_POSITION
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMagazinPresentationInput {
  images_1: ID
  text_1: String
  text_2: String
  images_2: ID
  position: ENUM_MAGAZINPRESENTATION_POSITION
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMagazinPresentationInput {
  data: MagazinPresentationInput
}

type createMagazinPresentationPayload {
  magazinPresentation: MagazinPresentation
}

input updateMagazinPresentationInput {
  where: InputID
  data: editMagazinPresentationInput
}

type updateMagazinPresentationPayload {
  magazinPresentation: MagazinPresentation
}

input deleteMagazinPresentationInput {
  where: InputID
}

type deleteMagazinPresentationPayload {
  magazinPresentation: MagazinPresentation
}

type MainAccount {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  addresses: String
  user_data: String
  orders: String
  wishlist: String
  newsletter: String
  my_bookmarks: String
  published_at: DateTime
}

type MainAccountConnection {
  values: [MainAccount]
  groupBy: MainAccountGroupBy
  aggregate: MainAccountAggregator
}

type MainAccountAggregator {
  count: Int
  totalCount: Int
}

type MainAccountGroupBy {
  id: [MainAccountConnectionId]
  created_at: [MainAccountConnectionCreated_at]
  updated_at: [MainAccountConnectionUpdated_at]
  addresses: [MainAccountConnectionAddresses]
  user_data: [MainAccountConnectionUser_data]
  orders: [MainAccountConnectionOrders]
  wishlist: [MainAccountConnectionWishlist]
  newsletter: [MainAccountConnectionNewsletter]
  my_bookmarks: [MainAccountConnectionMy_bookmarks]
  published_at: [MainAccountConnectionPublished_at]
}

type MainAccountConnectionId {
  key: ID
  connection: MainAccountConnection
}

type MainAccountConnectionCreated_at {
  key: DateTime
  connection: MainAccountConnection
}

type MainAccountConnectionUpdated_at {
  key: DateTime
  connection: MainAccountConnection
}

type MainAccountConnectionAddresses {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionUser_data {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionOrders {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionWishlist {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionNewsletter {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionMy_bookmarks {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionPublished_at {
  key: DateTime
  connection: MainAccountConnection
}

input MainAccountInput {
  addresses: String
  user_data: String
  orders: String
  wishlist: String
  newsletter: String
  my_bookmarks: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMainAccountInput {
  addresses: String
  user_data: String
  orders: String
  wishlist: String
  newsletter: String
  my_bookmarks: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMainAccountInput {
  data: MainAccountInput
}

type createMainAccountPayload {
  mainAccount: MainAccount
}

input updateMainAccountInput {
  where: InputID
  data: editMainAccountInput
}

type updateMainAccountPayload {
  mainAccount: MainAccount
}

input deleteMainAccountInput {
  where: InputID
}

type deleteMainAccountPayload {
  mainAccount: MainAccount
}

type MeinKonto {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  url: String
  published_at: DateTime
}

type MeinKontoConnection {
  values: [MeinKonto]
  groupBy: MeinKontoGroupBy
  aggregate: MeinKontoAggregator
}

type MeinKontoAggregator {
  count: Int
  totalCount: Int
}

type MeinKontoGroupBy {
  id: [MeinKontoConnectionId]
  created_at: [MeinKontoConnectionCreated_at]
  updated_at: [MeinKontoConnectionUpdated_at]
  title: [MeinKontoConnectionTitle]
  url: [MeinKontoConnectionUrl]
  published_at: [MeinKontoConnectionPublished_at]
}

type MeinKontoConnectionId {
  key: ID
  connection: MeinKontoConnection
}

type MeinKontoConnectionCreated_at {
  key: DateTime
  connection: MeinKontoConnection
}

type MeinKontoConnectionUpdated_at {
  key: DateTime
  connection: MeinKontoConnection
}

type MeinKontoConnectionTitle {
  key: String
  connection: MeinKontoConnection
}

type MeinKontoConnectionUrl {
  key: String
  connection: MeinKontoConnection
}

type MeinKontoConnectionPublished_at {
  key: DateTime
  connection: MeinKontoConnection
}

input MeinKontoInput {
  title: String
  url: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMeinKontoInput {
  title: String
  url: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMeinKontoInput {
  data: MeinKontoInput
}

type createMeinKontoPayload {
  meinKonto: MeinKonto
}

input updateMeinKontoInput {
  where: InputID
  data: editMeinKontoInput
}

type updateMeinKontoPayload {
  meinKonto: MeinKonto
}

input deleteMeinKontoInput {
  where: InputID
}

type deleteMeinKontoPayload {
  meinKonto: MeinKonto
}

enum ENUM_MENUITEM_POSITION {
  A
  B
  C
  D
  E
  F
  G
  H
  I
  J
  K
  L
  M
  N
  O
  P
  Q
}

type MenuItem {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  item_name: String
  title: String
  images: UploadFile
  url: String
  position: ENUM_MENUITEM_POSITION!
  published_at: DateTime
  categories(sort: String, limit: Int, start: Int, where: JSON): [Category]
  products(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type MenuItemConnection {
  values: [MenuItem]
  groupBy: MenuItemGroupBy
  aggregate: MenuItemAggregator
}

type MenuItemAggregator {
  count: Int
  totalCount: Int
}

type MenuItemGroupBy {
  id: [MenuItemConnectionId]
  created_at: [MenuItemConnectionCreated_at]
  updated_at: [MenuItemConnectionUpdated_at]
  item_name: [MenuItemConnectionItem_name]
  title: [MenuItemConnectionTitle]
  images: [MenuItemConnectionImages]
  url: [MenuItemConnectionUrl]
  position: [MenuItemConnectionPosition]
  published_at: [MenuItemConnectionPublished_at]
}

type MenuItemConnectionId {
  key: ID
  connection: MenuItemConnection
}

type MenuItemConnectionCreated_at {
  key: DateTime
  connection: MenuItemConnection
}

type MenuItemConnectionUpdated_at {
  key: DateTime
  connection: MenuItemConnection
}

type MenuItemConnectionItem_name {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionTitle {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionImages {
  key: ID
  connection: MenuItemConnection
}

type MenuItemConnectionUrl {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionPosition {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionPublished_at {
  key: DateTime
  connection: MenuItemConnection
}

input MenuItemInput {
  item_name: String
  categories: [ID]
  title: String
  images: ID
  url: String
  position: ENUM_MENUITEM_POSITION
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMenuItemInput {
  item_name: String
  categories: [ID]
  title: String
  images: ID
  url: String
  position: ENUM_MENUITEM_POSITION
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMenuItemInput {
  data: MenuItemInput
}

type createMenuItemPayload {
  menuItem: MenuItem
}

input updateMenuItemInput {
  where: InputID
  data: editMenuItemInput
}

type updateMenuItemPayload {
  menuItem: MenuItem
}

input deleteMenuItemInput {
  where: InputID
}

type deleteMenuItemPayload {
  menuItem: MenuItem
}

type MidFooter {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  images: UploadFile
  text_1: String
  text_2: String
  text_3: String
  published_at: DateTime
}

type MidFooterConnection {
  values: [MidFooter]
  groupBy: MidFooterGroupBy
  aggregate: MidFooterAggregator
}

type MidFooterAggregator {
  count: Int
  totalCount: Int
}

type MidFooterGroupBy {
  id: [MidFooterConnectionId]
  created_at: [MidFooterConnectionCreated_at]
  updated_at: [MidFooterConnectionUpdated_at]
  header: [MidFooterConnectionHeader]
  images: [MidFooterConnectionImages]
  text_1: [MidFooterConnectionText_1]
  text_2: [MidFooterConnectionText_2]
  text_3: [MidFooterConnectionText_3]
  published_at: [MidFooterConnectionPublished_at]
}

type MidFooterConnectionId {
  key: ID
  connection: MidFooterConnection
}

type MidFooterConnectionCreated_at {
  key: DateTime
  connection: MidFooterConnection
}

type MidFooterConnectionUpdated_at {
  key: DateTime
  connection: MidFooterConnection
}

type MidFooterConnectionHeader {
  key: String
  connection: MidFooterConnection
}

type MidFooterConnectionImages {
  key: ID
  connection: MidFooterConnection
}

type MidFooterConnectionText_1 {
  key: String
  connection: MidFooterConnection
}

type MidFooterConnectionText_2 {
  key: String
  connection: MidFooterConnection
}

type MidFooterConnectionText_3 {
  key: String
  connection: MidFooterConnection
}

type MidFooterConnectionPublished_at {
  key: DateTime
  connection: MidFooterConnection
}

input MidFooterInput {
  header: String
  images: ID
  text_1: String
  text_2: String
  text_3: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMidFooterInput {
  header: String
  images: ID
  text_1: String
  text_2: String
  text_3: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMidFooterInput {
  data: MidFooterInput
}

type createMidFooterPayload {
  midFooter: MidFooter
}

input updateMidFooterInput {
  where: InputID
  data: editMidFooterInput
}

type updateMidFooterPayload {
  midFooter: MidFooter
}

input deleteMidFooterInput {
  where: InputID
}

type deleteMidFooterPayload {
  midFooter: MidFooter
}

type NewProductLimit {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  new_product_limit: Long
  published_at: DateTime
}

input NewProductLimitInput {
  new_product_limit: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNewProductLimitInput {
  new_product_limit: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateNewProductLimitInput {
  data: editNewProductLimitInput
}

type updateNewProductLimitPayload {
  newProductLimit: NewProductLimit
}

type deleteNewProductLimitPayload {
  newProductLimit: NewProductLimit
}

enum ENUM_NEWSREPORT_POSITION {
  HomePageOne
  HomePageTwo
  HomePageThree
  HomePageFive
  HomePageFour
  HerrenPageOne
  HerrenPageTwo
  ShopPageOne
  ShopPageTwo
  ShopPageThree
  MagazinPageOne
  MagazinPageTwo
}

type NewsReport {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  text: String
  url: String
  link_text: String
  images: UploadFile
  position: ENUM_NEWSREPORT_POSITION!
  published_at: DateTime
}

type NewsReportConnection {
  values: [NewsReport]
  groupBy: NewsReportGroupBy
  aggregate: NewsReportAggregator
}

type NewsReportAggregator {
  count: Int
  totalCount: Int
}

type NewsReportGroupBy {
  id: [NewsReportConnectionId]
  created_at: [NewsReportConnectionCreated_at]
  updated_at: [NewsReportConnectionUpdated_at]
  header: [NewsReportConnectionHeader]
  title: [NewsReportConnectionTitle]
  text: [NewsReportConnectionText]
  url: [NewsReportConnectionUrl]
  link_text: [NewsReportConnectionLink_text]
  images: [NewsReportConnectionImages]
  position: [NewsReportConnectionPosition]
  published_at: [NewsReportConnectionPublished_at]
}

type NewsReportConnectionId {
  key: ID
  connection: NewsReportConnection
}

type NewsReportConnectionCreated_at {
  key: DateTime
  connection: NewsReportConnection
}

type NewsReportConnectionUpdated_at {
  key: DateTime
  connection: NewsReportConnection
}

type NewsReportConnectionHeader {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionTitle {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionText {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionUrl {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionLink_text {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionImages {
  key: ID
  connection: NewsReportConnection
}

type NewsReportConnectionPosition {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionPublished_at {
  key: DateTime
  connection: NewsReportConnection
}

input NewsReportInput {
  header: String
  title: String
  text: String
  url: String
  link_text: String
  images: ID
  position: ENUM_NEWSREPORT_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNewsReportInput {
  header: String
  title: String
  text: String
  url: String
  link_text: String
  images: ID
  position: ENUM_NEWSREPORT_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createNewsReportInput {
  data: NewsReportInput
}

type createNewsReportPayload {
  newsReport: NewsReport
}

input updateNewsReportInput {
  where: InputID
  data: editNewsReportInput
}

type updateNewsReportPayload {
  newsReport: NewsReport
}

input deleteNewsReportInput {
  where: InputID
}

type deleteNewsReportPayload {
  newsReport: NewsReport
}

type NewsletterText {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  text: String
  published_at: DateTime
}

type NewsletterTextConnection {
  values: [NewsletterText]
  groupBy: NewsletterTextGroupBy
  aggregate: NewsletterTextAggregator
}

type NewsletterTextAggregator {
  count: Int
  totalCount: Int
}

type NewsletterTextGroupBy {
  id: [NewsletterTextConnectionId]
  created_at: [NewsletterTextConnectionCreated_at]
  updated_at: [NewsletterTextConnectionUpdated_at]
  text: [NewsletterTextConnectionText]
  published_at: [NewsletterTextConnectionPublished_at]
}

type NewsletterTextConnectionId {
  key: ID
  connection: NewsletterTextConnection
}

type NewsletterTextConnectionCreated_at {
  key: DateTime
  connection: NewsletterTextConnection
}

type NewsletterTextConnectionUpdated_at {
  key: DateTime
  connection: NewsletterTextConnection
}

type NewsletterTextConnectionText {
  key: String
  connection: NewsletterTextConnection
}

type NewsletterTextConnectionPublished_at {
  key: DateTime
  connection: NewsletterTextConnection
}

input NewsletterTextInput {
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNewsletterTextInput {
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createNewsletterTextInput {
  data: NewsletterTextInput
}

type createNewsletterTextPayload {
  newsletterText: NewsletterText
}

input updateNewsletterTextInput {
  where: InputID
  data: editNewsletterTextInput
}

type updateNewsletterTextPayload {
  newsletterText: NewsletterText
}

input deleteNewsletterTextInput {
  where: InputID
}

type deleteNewsletterTextPayload {
  newsletterText: NewsletterText
}

type Newsletter {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Subject: String
  HTML_describe: String
  published_at: DateTime
}

type NewsletterConnection {
  values: [Newsletter]
  groupBy: NewsletterGroupBy
  aggregate: NewsletterAggregator
}

type NewsletterAggregator {
  count: Int
  totalCount: Int
}

type NewsletterGroupBy {
  id: [NewsletterConnectionId]
  created_at: [NewsletterConnectionCreated_at]
  updated_at: [NewsletterConnectionUpdated_at]
  Subject: [NewsletterConnectionSubject]
  HTML_describe: [NewsletterConnectionHTML_describe]
  published_at: [NewsletterConnectionPublished_at]
}

type NewsletterConnectionId {
  key: ID
  connection: NewsletterConnection
}

type NewsletterConnectionCreated_at {
  key: DateTime
  connection: NewsletterConnection
}

type NewsletterConnectionUpdated_at {
  key: DateTime
  connection: NewsletterConnection
}

type NewsletterConnectionSubject {
  key: String
  connection: NewsletterConnection
}

type NewsletterConnectionHTML_describe {
  key: String
  connection: NewsletterConnection
}

type NewsletterConnectionPublished_at {
  key: DateTime
  connection: NewsletterConnection
}

input NewsletterInput {
  Subject: String
  HTML_describe: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNewsletterInput {
  Subject: String
  HTML_describe: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createNewsletterInput {
  data: NewsletterInput
}

type createNewsletterPayload {
  newsletter: Newsletter
}

input updateNewsletterInput {
  where: InputID
  data: editNewsletterInput
}

type updateNewsletterPayload {
  newsletter: Newsletter
}

input deleteNewsletterInput {
  where: InputID
}

type deleteNewsletterPayload {
  newsletter: Newsletter
}

enum ENUM_PAGEHEADER_POSITION {
  grey
  black
}

type PageHeader {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  describe_HTML_CSS: String
  position: ENUM_PAGEHEADER_POSITION
  published_at: DateTime
}

type PageHeaderConnection {
  values: [PageHeader]
  groupBy: PageHeaderGroupBy
  aggregate: PageHeaderAggregator
}

type PageHeaderAggregator {
  count: Int
  totalCount: Int
}

type PageHeaderGroupBy {
  id: [PageHeaderConnectionId]
  created_at: [PageHeaderConnectionCreated_at]
  updated_at: [PageHeaderConnectionUpdated_at]
  describe_HTML_CSS: [PageHeaderConnectionDescribe_HTML_CSS]
  position: [PageHeaderConnectionPosition]
  published_at: [PageHeaderConnectionPublished_at]
}

type PageHeaderConnectionId {
  key: ID
  connection: PageHeaderConnection
}

type PageHeaderConnectionCreated_at {
  key: DateTime
  connection: PageHeaderConnection
}

type PageHeaderConnectionUpdated_at {
  key: DateTime
  connection: PageHeaderConnection
}

type PageHeaderConnectionDescribe_HTML_CSS {
  key: String
  connection: PageHeaderConnection
}

type PageHeaderConnectionPosition {
  key: String
  connection: PageHeaderConnection
}

type PageHeaderConnectionPublished_at {
  key: DateTime
  connection: PageHeaderConnection
}

input PageHeaderInput {
  describe_HTML_CSS: String
  position: ENUM_PAGEHEADER_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPageHeaderInput {
  describe_HTML_CSS: String
  position: ENUM_PAGEHEADER_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPageHeaderInput {
  data: PageHeaderInput
}

type createPageHeaderPayload {
  pageHeader: PageHeader
}

input updatePageHeaderInput {
  where: InputID
  data: editPageHeaderInput
}

type updatePageHeaderPayload {
  pageHeader: PageHeader
}

input deletePageHeaderInput {
  where: InputID
}

type deletePageHeaderPayload {
  pageHeader: PageHeader
}

type Parfums {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
}

type ParfumsConnection {
  values: [Parfums]
  groupBy: ParfumsGroupBy
  aggregate: ParfumsAggregator
}

type ParfumsAggregator {
  count: Int
  totalCount: Int
}

type ParfumsGroupBy {
  id: [ParfumsConnectionId]
  created_at: [ParfumsConnectionCreated_at]
  updated_at: [ParfumsConnectionUpdated_at]
  productId: [ParfumsConnectionProductId]
  images: [ParfumsConnectionImages]
  New_Date_Limit: [ParfumsConnectionNew_Date_Limit]
  limited_edition: [ParfumsConnectionLimited_edition]
  brand: [ParfumsConnectionBrand]
  kind: [ParfumsConnectionKind]
  name: [ParfumsConnectionName]
  price: [ParfumsConnectionPrice]
  clean_product: [ParfumsConnectionClean_product]
  published_at: [ParfumsConnectionPublished_at]
}

type ParfumsConnectionId {
  key: ID
  connection: ParfumsConnection
}

type ParfumsConnectionCreated_at {
  key: DateTime
  connection: ParfumsConnection
}

type ParfumsConnectionUpdated_at {
  key: DateTime
  connection: ParfumsConnection
}

type ParfumsConnectionProductId {
  key: ID
  connection: ParfumsConnection
}

type ParfumsConnectionImages {
  key: String
  connection: ParfumsConnection
}

type ParfumsConnectionNew_Date_Limit {
  key: ID
  connection: ParfumsConnection
}

type ParfumsConnectionLimited_edition {
  key: Boolean
  connection: ParfumsConnection
}

type ParfumsConnectionBrand {
  key: String
  connection: ParfumsConnection
}

type ParfumsConnectionKind {
  key: String
  connection: ParfumsConnection
}

type ParfumsConnectionName {
  key: String
  connection: ParfumsConnection
}

type ParfumsConnectionPrice {
  key: ID
  connection: ParfumsConnection
}

type ParfumsConnectionClean_product {
  key: Boolean
  connection: ParfumsConnection
}

type ParfumsConnectionPublished_at {
  key: DateTime
  connection: ParfumsConnection
}

input ParfumInput {
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editParfumInput {
  productId: Long
  images: String
  New_Date_Limit: Date
  limited_edition: Boolean
  brand: String
  kind: String
  name: String
  price: Long
  clean_product: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createParfumInput {
  data: ParfumInput
}

type createParfumPayload {
  parfum: Parfums
}

input updateParfumInput {
  where: InputID
  data: editParfumInput
}

type updateParfumPayload {
  parfum: Parfums
}

input deleteParfumInput {
  where: InputID
}

type deleteParfumPayload {
  parfum: Parfums
}

type PermanentDiscount {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  value: Long
  discount: Long
  published_at: DateTime
}

input PermanentDiscountInput {
  value: Long
  discount: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPermanentDiscountInput {
  value: Long
  discount: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updatePermanentDiscountInput {
  data: editPermanentDiscountInput
}

type updatePermanentDiscountPayload {
  permanentDiscount: PermanentDiscount
}

type deletePermanentDiscountPayload {
  permanentDiscount: PermanentDiscount
}

enum ENUM_PRODUCTWITHLEFTTEXT_POSITION {
  HomePageOne
  HomePageTwo
}

type ProductWithLeftText {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Header: String
  Title: String
  Text: String
  Button_text: String
  url: String
  position: ENUM_PRODUCTWITHLEFTTEXT_POSITION!
  published_at: DateTime
}

type ProductWithLeftTextConnection {
  values: [ProductWithLeftText]
  groupBy: ProductWithLeftTextGroupBy
  aggregate: ProductWithLeftTextAggregator
}

type ProductWithLeftTextAggregator {
  count: Int
  totalCount: Int
}

type ProductWithLeftTextGroupBy {
  id: [ProductWithLeftTextConnectionId]
  created_at: [ProductWithLeftTextConnectionCreated_at]
  updated_at: [ProductWithLeftTextConnectionUpdated_at]
  Header: [ProductWithLeftTextConnectionHeader]
  Title: [ProductWithLeftTextConnectionTitle]
  Text: [ProductWithLeftTextConnectionText]
  Button_text: [ProductWithLeftTextConnectionButton_text]
  url: [ProductWithLeftTextConnectionUrl]
  position: [ProductWithLeftTextConnectionPosition]
  published_at: [ProductWithLeftTextConnectionPublished_at]
}

type ProductWithLeftTextConnectionId {
  key: ID
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionCreated_at {
  key: DateTime
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionUpdated_at {
  key: DateTime
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionHeader {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionTitle {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionText {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionButton_text {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionUrl {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionPosition {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionPublished_at {
  key: DateTime
  connection: ProductWithLeftTextConnection
}

input ProductWithLeftTextInput {
  Header: String
  Title: String
  Text: String
  Button_text: String
  url: String
  position: ENUM_PRODUCTWITHLEFTTEXT_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductWithLeftTextInput {
  Header: String
  Title: String
  Text: String
  Button_text: String
  url: String
  position: ENUM_PRODUCTWITHLEFTTEXT_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductWithLeftTextInput {
  data: ProductWithLeftTextInput
}

type createProductWithLeftTextPayload {
  productWithLeftText: ProductWithLeftText
}

input updateProductWithLeftTextInput {
  where: InputID
  data: editProductWithLeftTextInput
}

type updateProductWithLeftTextPayload {
  productWithLeftText: ProductWithLeftText
}

input deleteProductWithLeftTextInput {
  where: InputID
}

type deleteProductWithLeftTextPayload {
  productWithLeftText: ProductWithLeftText
}

type Products {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  clean_product: Boolean
  brand: String
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: TypeTest
  category: Category
  sub_category: SubCategory
  menu_item: MenuItem
  name: String
  magazin_presentation: MagazinPresentation
  kind: String
  New_Date_Limit: Date
  video: UploadFile
  price: Long
  limited_edition: Boolean
  video_description: String
  video_status: String
  video_name: String
  published_at: DateTime
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  favorite_products(sort: String, limit: Int, start: Int, where: JSON): [FavoriteProduct]
}

type ProductsConnection {
  values: [Products]
  groupBy: ProductsGroupBy
  aggregate: ProductsAggregator
}

type ProductsAggregator {
  count: Int
  totalCount: Int
}

type ProductsGroupBy {
  id: [ProductsConnectionId]
  created_at: [ProductsConnectionCreated_at]
  updated_at: [ProductsConnectionUpdated_at]
  clean_product: [ProductsConnectionClean_product]
  brand: [ProductsConnectionBrand]
  for_sale_count: [ProductsConnectionFor_sale_count]
  unit: [ProductsConnectionUnit]
  discount: [ProductsConnectionDiscount]
  type_test: [ProductsConnectionType_test]
  category: [ProductsConnectionCategory]
  sub_category: [ProductsConnectionSub_category]
  menu_item: [ProductsConnectionMenu_item]
  name: [ProductsConnectionName]
  magazin_presentation: [ProductsConnectionMagazin_presentation]
  kind: [ProductsConnectionKind]
  New_Date_Limit: [ProductsConnectionNew_Date_Limit]
  video: [ProductsConnectionVideo]
  price: [ProductsConnectionPrice]
  limited_edition: [ProductsConnectionLimited_edition]
  video_description: [ProductsConnectionVideo_description]
  video_status: [ProductsConnectionVideo_status]
  video_name: [ProductsConnectionVideo_name]
  published_at: [ProductsConnectionPublished_at]
}

type ProductsConnectionId {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionCreated_at {
  key: DateTime
  connection: ProductsConnection
}

type ProductsConnectionUpdated_at {
  key: DateTime
  connection: ProductsConnection
}

type ProductsConnectionClean_product {
  key: Boolean
  connection: ProductsConnection
}

type ProductsConnectionBrand {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionFor_sale_count {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionUnit {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionDiscount {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionType_test {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionCategory {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionSub_category {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionMenu_item {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionName {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionMagazin_presentation {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionKind {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionNew_Date_Limit {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionVideo {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionPrice {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionLimited_edition {
  key: Boolean
  connection: ProductsConnection
}

type ProductsConnectionVideo_description {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionVideo_status {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionVideo_name {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionPublished_at {
  key: DateTime
  connection: ProductsConnection
}

input ProductInput {
  images: [ID]
  clean_product: Boolean
  brand: String
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: ID
  category: ID
  sub_category: ID
  menu_item: ID
  name: String
  magazin_presentation: ID
  kind: String
  New_Date_Limit: Date
  video: ID
  price: Long
  limited_edition: Boolean
  video_description: String
  video_status: String
  video_name: String
  favorite_products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductInput {
  images: [ID]
  clean_product: Boolean
  brand: String
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: ID
  category: ID
  sub_category: ID
  menu_item: ID
  name: String
  magazin_presentation: ID
  kind: String
  New_Date_Limit: Date
  video: ID
  price: Long
  limited_edition: Boolean
  video_description: String
  video_status: String
  video_name: String
  favorite_products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductInput {
  data: ProductInput
}

type createProductPayload {
  product: Products
}

input updateProductInput {
  where: InputID
  data: editProductInput
}

type updateProductPayload {
  product: Products
}

input deleteProductInput {
  where: InputID
}

type deleteProductPayload {
  product: Products
}

enum ENUM_SECTIONUNDERNAVBAR_POSITION {
  HomePage
  HerrenPage
}

type SectionUnderNavbar {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  button_text: String
  url: String
  images: UploadFile
  position: ENUM_SECTIONUNDERNAVBAR_POSITION!
  published_at: DateTime
}

type SectionUnderNavbarConnection {
  values: [SectionUnderNavbar]
  groupBy: SectionUnderNavbarGroupBy
  aggregate: SectionUnderNavbarAggregator
}

type SectionUnderNavbarAggregator {
  count: Int
  totalCount: Int
}

type SectionUnderNavbarGroupBy {
  id: [SectionUnderNavbarConnectionId]
  created_at: [SectionUnderNavbarConnectionCreated_at]
  updated_at: [SectionUnderNavbarConnectionUpdated_at]
  header: [SectionUnderNavbarConnectionHeader]
  title: [SectionUnderNavbarConnectionTitle]
  button_text: [SectionUnderNavbarConnectionButton_text]
  url: [SectionUnderNavbarConnectionUrl]
  images: [SectionUnderNavbarConnectionImages]
  position: [SectionUnderNavbarConnectionPosition]
  published_at: [SectionUnderNavbarConnectionPublished_at]
}

type SectionUnderNavbarConnectionId {
  key: ID
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionCreated_at {
  key: DateTime
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionUpdated_at {
  key: DateTime
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionHeader {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionTitle {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionButton_text {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionUrl {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionImages {
  key: ID
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionPosition {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionPublished_at {
  key: DateTime
  connection: SectionUnderNavbarConnection
}

input SectionUnderNavbarInput {
  header: String
  title: String
  button_text: String
  url: String
  images: ID
  position: ENUM_SECTIONUNDERNAVBAR_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editSectionUnderNavbarInput {
  header: String
  title: String
  button_text: String
  url: String
  images: ID
  position: ENUM_SECTIONUNDERNAVBAR_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createSectionUnderNavbarInput {
  data: SectionUnderNavbarInput
}

type createSectionUnderNavbarPayload {
  sectionUnderNavbar: SectionUnderNavbar
}

input updateSectionUnderNavbarInput {
  where: InputID
  data: editSectionUnderNavbarInput
}

type updateSectionUnderNavbarPayload {
  sectionUnderNavbar: SectionUnderNavbar
}

input deleteSectionUnderNavbarInput {
  where: InputID
}

type deleteSectionUnderNavbarPayload {
  sectionUnderNavbar: SectionUnderNavbar
}

type ShopPageLargeText {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  text: String
  published_at: DateTime
}

type ShopPageLargeTextConnection {
  values: [ShopPageLargeText]
  groupBy: ShopPageLargeTextGroupBy
  aggregate: ShopPageLargeTextAggregator
}

type ShopPageLargeTextAggregator {
  count: Int
  totalCount: Int
}

type ShopPageLargeTextGroupBy {
  id: [ShopPageLargeTextConnectionId]
  created_at: [ShopPageLargeTextConnectionCreated_at]
  updated_at: [ShopPageLargeTextConnectionUpdated_at]
  header: [ShopPageLargeTextConnectionHeader]
  text: [ShopPageLargeTextConnectionText]
  published_at: [ShopPageLargeTextConnectionPublished_at]
}

type ShopPageLargeTextConnectionId {
  key: ID
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionCreated_at {
  key: DateTime
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionUpdated_at {
  key: DateTime
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionHeader {
  key: String
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionText {
  key: String
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionPublished_at {
  key: DateTime
  connection: ShopPageLargeTextConnection
}

input ShopPageLargeTextInput {
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShopPageLargeTextInput {
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShopPageLargeTextInput {
  data: ShopPageLargeTextInput
}

type createShopPageLargeTextPayload {
  shopPageLargeText: ShopPageLargeText
}

input updateShopPageLargeTextInput {
  where: InputID
  data: editShopPageLargeTextInput
}

type updateShopPageLargeTextPayload {
  shopPageLargeText: ShopPageLargeText
}

input deleteShopPageLargeTextInput {
  where: InputID
}

type deleteShopPageLargeTextPayload {
  shopPageLargeText: ShopPageLargeText
}

type ShoppingBasketRecommendation {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  to: String
  from: String
  current_shopping_basket_product_id: JSON
  published_at: DateTime
}

type ShoppingBasketRecommendationConnection {
  values: [ShoppingBasketRecommendation]
  groupBy: ShoppingBasketRecommendationGroupBy
  aggregate: ShoppingBasketRecommendationAggregator
}

type ShoppingBasketRecommendationAggregator {
  count: Int
  totalCount: Int
}

type ShoppingBasketRecommendationGroupBy {
  id: [ShoppingBasketRecommendationConnectionId]
  created_at: [ShoppingBasketRecommendationConnectionCreated_at]
  updated_at: [ShoppingBasketRecommendationConnectionUpdated_at]
  to: [ShoppingBasketRecommendationConnectionTo]
  from: [ShoppingBasketRecommendationConnectionFrom]
  current_shopping_basket_product_id: [ShoppingBasketRecommendationConnectionCurrent_shopping_basket_product_id]
  published_at: [ShoppingBasketRecommendationConnectionPublished_at]
}

type ShoppingBasketRecommendationConnectionId {
  key: ID
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionCreated_at {
  key: DateTime
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionUpdated_at {
  key: DateTime
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionTo {
  key: String
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionFrom {
  key: String
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionCurrent_shopping_basket_product_id {
  key: JSON
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionPublished_at {
  key: DateTime
  connection: ShoppingBasketRecommendationConnection
}

input ShoppingBasketRecommendationInput {
  to: String
  from: String
  current_shopping_basket_product_id: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShoppingBasketRecommendationInput {
  to: String
  from: String
  current_shopping_basket_product_id: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShoppingBasketRecommendationInput {
  data: ShoppingBasketRecommendationInput
}

type createShoppingBasketRecommendationPayload {
  shoppingBasketRecommendation: ShoppingBasketRecommendation
}

input updateShoppingBasketRecommendationInput {
  where: InputID
  data: editShoppingBasketRecommendationInput
}

type updateShoppingBasketRecommendationPayload {
  shoppingBasketRecommendation: ShoppingBasketRecommendation
}

input deleteShoppingBasketRecommendationInput {
  where: InputID
}

type deleteShoppingBasketRecommendationPayload {
  shoppingBasketRecommendation: ShoppingBasketRecommendation
}

type ShoppingBasket {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  users_permissions_user: UsersPermissionsUser
  product: Products
  gift_wrap: GiftWrap
  type_test: TypeTest
  quantity: Long
  published_at: DateTime
}

type ShoppingBasketConnection {
  values: [ShoppingBasket]
  groupBy: ShoppingBasketGroupBy
  aggregate: ShoppingBasketAggregator
}

type ShoppingBasketAggregator {
  count: Int
  totalCount: Int
}

type ShoppingBasketGroupBy {
  id: [ShoppingBasketConnectionId]
  created_at: [ShoppingBasketConnectionCreated_at]
  updated_at: [ShoppingBasketConnectionUpdated_at]
  users_permissions_user: [ShoppingBasketConnectionUsers_permissions_user]
  product: [ShoppingBasketConnectionProduct]
  gift_wrap: [ShoppingBasketConnectionGift_wrap]
  type_test: [ShoppingBasketConnectionType_test]
  quantity: [ShoppingBasketConnectionQuantity]
  published_at: [ShoppingBasketConnectionPublished_at]
}

type ShoppingBasketConnectionId {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionCreated_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionUpdated_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionUsers_permissions_user {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionProduct {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionGift_wrap {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionType_test {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionQuantity {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionPublished_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

input ShoppingBasketInput {
  users_permissions_user: ID
  product: ID
  gift_wrap: ID
  type_test: ID
  quantity: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShoppingBasketInput {
  users_permissions_user: ID
  product: ID
  gift_wrap: ID
  type_test: ID
  quantity: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShoppingBasketInput {
  data: ShoppingBasketInput
}

type createShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

input updateShoppingBasketInput {
  where: InputID
  data: editShoppingBasketInput
}

type updateShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

input deleteShoppingBasketInput {
  where: InputID
}

type deleteShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

enum ENUM_STAIRSECTION_POSITION {
  One
  Two
  Three
  Four
  Five
  Six
}

type StairSection {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  image: UploadFile
  header: String
  text: String
  date: DateTime
  position: ENUM_STAIRSECTION_POSITION!
  published_at: DateTime
}

type StairSectionConnection {
  values: [StairSection]
  groupBy: StairSectionGroupBy
  aggregate: StairSectionAggregator
}

type StairSectionAggregator {
  count: Int
  totalCount: Int
}

type StairSectionGroupBy {
  id: [StairSectionConnectionId]
  created_at: [StairSectionConnectionCreated_at]
  updated_at: [StairSectionConnectionUpdated_at]
  image: [StairSectionConnectionImage]
  header: [StairSectionConnectionHeader]
  text: [StairSectionConnectionText]
  date: [StairSectionConnectionDate]
  position: [StairSectionConnectionPosition]
  published_at: [StairSectionConnectionPublished_at]
}

type StairSectionConnectionId {
  key: ID
  connection: StairSectionConnection
}

type StairSectionConnectionCreated_at {
  key: DateTime
  connection: StairSectionConnection
}

type StairSectionConnectionUpdated_at {
  key: DateTime
  connection: StairSectionConnection
}

type StairSectionConnectionImage {
  key: ID
  connection: StairSectionConnection
}

type StairSectionConnectionHeader {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionText {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionDate {
  key: DateTime
  connection: StairSectionConnection
}

type StairSectionConnectionPosition {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionPublished_at {
  key: DateTime
  connection: StairSectionConnection
}

input StairSectionInput {
  image: ID
  header: String
  text: String
  date: DateTime
  position: ENUM_STAIRSECTION_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editStairSectionInput {
  image: ID
  header: String
  text: String
  date: DateTime
  position: ENUM_STAIRSECTION_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createStairSectionInput {
  data: StairSectionInput
}

type createStairSectionPayload {
  stairSection: StairSection
}

input updateStairSectionInput {
  where: InputID
  data: editStairSectionInput
}

type updateStairSectionPayload {
  stairSection: StairSection
}

input deleteStairSectionInput {
  where: InputID
}

type deleteStairSectionPayload {
  stairSection: StairSection
}

type Style {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  images: UploadFile
  text: String
  link_text: String
  link: String
  published_at: DateTime
}

type StyleConnection {
  values: [Style]
  groupBy: StyleGroupBy
  aggregate: StyleAggregator
}

type StyleAggregator {
  count: Int
  totalCount: Int
}

type StyleGroupBy {
  id: [StyleConnectionId]
  created_at: [StyleConnectionCreated_at]
  updated_at: [StyleConnectionUpdated_at]
  images: [StyleConnectionImages]
  text: [StyleConnectionText]
  link_text: [StyleConnectionLink_text]
  link: [StyleConnectionLink]
  published_at: [StyleConnectionPublished_at]
}

type StyleConnectionId {
  key: ID
  connection: StyleConnection
}

type StyleConnectionCreated_at {
  key: DateTime
  connection: StyleConnection
}

type StyleConnectionUpdated_at {
  key: DateTime
  connection: StyleConnection
}

type StyleConnectionImages {
  key: ID
  connection: StyleConnection
}

type StyleConnectionText {
  key: String
  connection: StyleConnection
}

type StyleConnectionLink_text {
  key: String
  connection: StyleConnection
}

type StyleConnectionLink {
  key: String
  connection: StyleConnection
}

type StyleConnectionPublished_at {
  key: DateTime
  connection: StyleConnection
}

input StyleInput {
  images: ID
  text: String
  link_text: String
  link: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editStyleInput {
  images: ID
  text: String
  link_text: String
  link: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createStyleInput {
  data: StyleInput
}

type createStylePayload {
  style: Style
}

input updateStyleInput {
  where: InputID
  data: editStyleInput
}

type updateStylePayload {
  style: Style
}

input deleteStyleInput {
  where: InputID
}

type deleteStylePayload {
  style: Style
}

type SubCategory {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  SubCategoryName: String!
  published_at: DateTime
}

type SubCategoryConnection {
  values: [SubCategory]
  groupBy: SubCategoryGroupBy
  aggregate: SubCategoryAggregator
}

type SubCategoryAggregator {
  count: Int
  totalCount: Int
}

type SubCategoryGroupBy {
  id: [SubCategoryConnectionId]
  created_at: [SubCategoryConnectionCreated_at]
  updated_at: [SubCategoryConnectionUpdated_at]
  SubCategoryName: [SubCategoryConnectionSubCategoryName]
  published_at: [SubCategoryConnectionPublished_at]
}

type SubCategoryConnectionId {
  key: ID
  connection: SubCategoryConnection
}

type SubCategoryConnectionCreated_at {
  key: DateTime
  connection: SubCategoryConnection
}

type SubCategoryConnectionUpdated_at {
  key: DateTime
  connection: SubCategoryConnection
}

type SubCategoryConnectionSubCategoryName {
  key: String
  connection: SubCategoryConnection
}

type SubCategoryConnectionPublished_at {
  key: DateTime
  connection: SubCategoryConnection
}

input SubCategoryInput {
  SubCategoryName: String!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editSubCategoryInput {
  SubCategoryName: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createSubCategoryInput {
  data: SubCategoryInput
}

type createSubCategoryPayload {
  subCategory: SubCategory
}

input updateSubCategoryInput {
  where: InputID
  data: editSubCategoryInput
}

type updateSubCategoryPayload {
  subCategory: SubCategory
}

input deleteSubCategoryInput {
  where: InputID
}

type deleteSubCategoryPayload {
  subCategory: SubCategory
}

type TopOfTheFooter {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  images: UploadFile
  header: String
  text: String
  published_at: DateTime
}

type TopOfTheFooterConnection {
  values: [TopOfTheFooter]
  groupBy: TopOfTheFooterGroupBy
  aggregate: TopOfTheFooterAggregator
}

type TopOfTheFooterAggregator {
  count: Int
  totalCount: Int
}

type TopOfTheFooterGroupBy {
  id: [TopOfTheFooterConnectionId]
  created_at: [TopOfTheFooterConnectionCreated_at]
  updated_at: [TopOfTheFooterConnectionUpdated_at]
  images: [TopOfTheFooterConnectionImages]
  header: [TopOfTheFooterConnectionHeader]
  text: [TopOfTheFooterConnectionText]
  published_at: [TopOfTheFooterConnectionPublished_at]
}

type TopOfTheFooterConnectionId {
  key: ID
  connection: TopOfTheFooterConnection
}

type TopOfTheFooterConnectionCreated_at {
  key: DateTime
  connection: TopOfTheFooterConnection
}

type TopOfTheFooterConnectionUpdated_at {
  key: DateTime
  connection: TopOfTheFooterConnection
}

type TopOfTheFooterConnectionImages {
  key: ID
  connection: TopOfTheFooterConnection
}

type TopOfTheFooterConnectionHeader {
  key: String
  connection: TopOfTheFooterConnection
}

type TopOfTheFooterConnectionText {
  key: String
  connection: TopOfTheFooterConnection
}

type TopOfTheFooterConnectionPublished_at {
  key: DateTime
  connection: TopOfTheFooterConnection
}

input TopOfTheFooterInput {
  images: ID
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editTopOfTheFooterInput {
  images: ID
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createTopOfTheFooterInput {
  data: TopOfTheFooterInput
}

type createTopOfTheFooterPayload {
  topOfTheFooter: TopOfTheFooter
}

input updateTopOfTheFooterInput {
  where: InputID
  data: editTopOfTheFooterInput
}

type updateTopOfTheFooterPayload {
  topOfTheFooter: TopOfTheFooter
}

input deleteTopOfTheFooterInput {
  where: InputID
}

type deleteTopOfTheFooterPayload {
  topOfTheFooter: TopOfTheFooter
}

type TypeTest {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  brand: String
  price: Float
  size: Long
  quantity: Long
  product: Products
  images: UploadFile
  published_at: DateTime
}

type TypeTestConnection {
  values: [TypeTest]
  groupBy: TypeTestGroupBy
  aggregate: TypeTestAggregator
}

type TypeTestAggregator {
  count: Int
  totalCount: Int
  sum: TypeTestAggregatorSum
  avg: TypeTestAggregatorAvg
  min: TypeTestAggregatorMin
  max: TypeTestAggregatorMax
}

type TypeTestAggregatorSum {
  price: Float
}

type TypeTestAggregatorAvg {
  price: Float
}

type TypeTestAggregatorMin {
  price: Float
}

type TypeTestAggregatorMax {
  price: Float
}

type TypeTestGroupBy {
  id: [TypeTestConnectionId]
  created_at: [TypeTestConnectionCreated_at]
  updated_at: [TypeTestConnectionUpdated_at]
  brand: [TypeTestConnectionBrand]
  price: [TypeTestConnectionPrice]
  size: [TypeTestConnectionSize]
  quantity: [TypeTestConnectionQuantity]
  product: [TypeTestConnectionProduct]
  images: [TypeTestConnectionImages]
  published_at: [TypeTestConnectionPublished_at]
}

type TypeTestConnectionId {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionCreated_at {
  key: DateTime
  connection: TypeTestConnection
}

type TypeTestConnectionUpdated_at {
  key: DateTime
  connection: TypeTestConnection
}

type TypeTestConnectionBrand {
  key: String
  connection: TypeTestConnection
}

type TypeTestConnectionPrice {
  key: Float
  connection: TypeTestConnection
}

type TypeTestConnectionSize {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionQuantity {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionProduct {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionImages {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionPublished_at {
  key: DateTime
  connection: TypeTestConnection
}

input TypeTestInput {
  brand: String
  price: Float
  size: Long
  quantity: Long
  product: ID
  images: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editTypeTestInput {
  brand: String
  price: Float
  size: Long
  quantity: Long
  product: ID
  images: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createTypeTestInput {
  data: TypeTestInput
}

type createTypeTestPayload {
  typeTest: TypeTest
}

input updateTypeTestInput {
  where: InputID
  data: editTypeTestInput
}

type updateTypeTestPayload {
  typeTest: TypeTest
}

input deleteTypeTestInput {
  where: InputID
}

type deleteTypeTestPayload {
  typeTest: TypeTest
}

type UserNewsletter {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  First_name: String
  Surname: String
  Gender: String
  Email: String
  published_at: DateTime
}

type UserNewsletterConnection {
  values: [UserNewsletter]
  groupBy: UserNewsletterGroupBy
  aggregate: UserNewsletterAggregator
}

type UserNewsletterAggregator {
  count: Int
  totalCount: Int
}

type UserNewsletterGroupBy {
  id: [UserNewsletterConnectionId]
  created_at: [UserNewsletterConnectionCreated_at]
  updated_at: [UserNewsletterConnectionUpdated_at]
  First_name: [UserNewsletterConnectionFirst_name]
  Surname: [UserNewsletterConnectionSurname]
  Gender: [UserNewsletterConnectionGender]
  Email: [UserNewsletterConnectionEmail]
  published_at: [UserNewsletterConnectionPublished_at]
}

type UserNewsletterConnectionId {
  key: ID
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionCreated_at {
  key: DateTime
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionUpdated_at {
  key: DateTime
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionFirst_name {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionSurname {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionGender {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionEmail {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionPublished_at {
  key: DateTime
  connection: UserNewsletterConnection
}

input UserNewsletterInput {
  First_name: String
  Surname: String
  Gender: String
  Email: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editUserNewsletterInput {
  First_name: String
  Surname: String
  Gender: String
  Email: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createUserNewsletterInput {
  data: UserNewsletterInput
}

type createUserNewsletterPayload {
  userNewsletter: UserNewsletter
}

input updateUserNewsletterInput {
  where: InputID
  data: editUserNewsletterInput
}

type updateUserNewsletterPayload {
  userNewsletter: UserNewsletter
}

input deleteUserNewsletterInput {
  where: InputID
}

type deleteUserNewsletterPayload {
  userNewsletter: UserNewsletter
}

type Videos {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  video_status: String
  video_name: String
  description: String
  url: String
  video_id: Long
  bookmark: Bookmark
  published_at: DateTime
}

type VideosConnection {
  values: [Videos]
  groupBy: VideosGroupBy
  aggregate: VideosAggregator
}

type VideosAggregator {
  count: Int
  totalCount: Int
}

type VideosGroupBy {
  id: [VideosConnectionId]
  created_at: [VideosConnectionCreated_at]
  updated_at: [VideosConnectionUpdated_at]
  video_status: [VideosConnectionVideo_status]
  video_name: [VideosConnectionVideo_name]
  description: [VideosConnectionDescription]
  url: [VideosConnectionUrl]
  video_id: [VideosConnectionVideo_id]
  bookmark: [VideosConnectionBookmark]
  published_at: [VideosConnectionPublished_at]
}

type VideosConnectionId {
  key: ID
  connection: VideosConnection
}

type VideosConnectionCreated_at {
  key: DateTime
  connection: VideosConnection
}

type VideosConnectionUpdated_at {
  key: DateTime
  connection: VideosConnection
}

type VideosConnectionVideo_status {
  key: String
  connection: VideosConnection
}

type VideosConnectionVideo_name {
  key: String
  connection: VideosConnection
}

type VideosConnectionDescription {
  key: String
  connection: VideosConnection
}

type VideosConnectionUrl {
  key: String
  connection: VideosConnection
}

type VideosConnectionVideo_id {
  key: ID
  connection: VideosConnection
}

type VideosConnectionBookmark {
  key: ID
  connection: VideosConnection
}

type VideosConnectionPublished_at {
  key: DateTime
  connection: VideosConnection
}

input VideoInput {
  video_status: String
  video_name: String
  description: String
  url: String
  video_id: Long
  bookmark: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVideoInput {
  video_status: String
  video_name: String
  description: String
  url: String
  video_id: Long
  bookmark: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVideoInput {
  data: VideoInput
}

type createVideoPayload {
  video: Videos
}

input updateVideoInput {
  where: InputID
  data: editVideoInput
}

type updateVideoPayload {
  video: Videos
}

input deleteVideoInput {
  where: InputID
}

type deleteVideoPayload {
  video: Videos
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  regular_customer: Boolean
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
  regular_customer: [UsersPermissionsUserConnectionRegular_customer]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRegular_customer {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  images: [ID]
  regular_customer: Boolean
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  images: [ID]
  regular_customer: Boolean
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | Beauty | BeautyConnection | BeautyAggregator | BeautyGroupBy | BeautyConnectionId | BeautyConnectionCreated_at | BeautyConnectionUpdated_at | BeautyConnectionProductId | BeautyConnectionImages | BeautyConnectionNew_Date_Limit | BeautyConnectionLimited_edition | BeautyConnectionBrand | BeautyConnectionKind | BeautyConnectionName | BeautyConnectionPrice | BeautyConnectionClean_product | BeautyConnectionPublished_at | createBeautyPayload | updateBeautyPayload | deleteBeautyPayload | Bookmark | BookmarkConnection | BookmarkAggregator | BookmarkGroupBy | BookmarkConnectionId | BookmarkConnectionCreated_at | BookmarkConnectionUpdated_at | BookmarkConnectionUsers_permissions_user | BookmarkConnectionVideo | BookmarkConnectionPublished_at | createBookmarkPayload | updateBookmarkPayload | deleteBookmarkPayload | Category | CategoryConnection | CategoryAggregator | CategoryGroupBy | CategoryConnectionId | CategoryConnectionCreated_at | CategoryConnectionUpdated_at | CategoryConnectionCategoryName | CategoryConnectionPublished_at | createCategoryPayload | updateCategoryPayload | deleteCategoryPayload | CollectionShop | CollectionShopConnection | CollectionShopAggregator | CollectionShopGroupBy | CollectionShopConnectionId | CollectionShopConnectionCreated_at | CollectionShopConnectionUpdated_at | CollectionShopConnectionHeader | CollectionShopConnectionTitle | CollectionShopConnectionUrl | CollectionShopConnectionImages | CollectionShopConnectionLink_text | CollectionShopConnectionPosition | CollectionShopConnectionPublished_at | createCollectionShopPayload | updateCollectionShopPayload | deleteCollectionShopPayload | ContactDetails | ContactDetailsConnection | ContactDetailsAggregator | ContactDetailsGroupBy | ContactDetailsConnectionId | ContactDetailsConnectionCreated_at | ContactDetailsConnectionUpdated_at | ContactDetailsConnectionEmail | ContactDetailsConnectionPhone_number | ContactDetailsConnectionPublished_at | createContactDetailPayload | updateContactDetailPayload | deleteContactDetailPayload | Contact | ContactConnection | ContactAggregator | ContactGroupBy | ContactConnectionId | ContactConnectionCreated_at | ContactConnectionUpdated_at | ContactConnectionTitle | ContactConnectionValue | ContactConnectionPublished_at | createContactPayload | updateContactPayload | deleteContactPayload | DiscountCodes | DiscountCodesConnection | DiscountCodesAggregator | DiscountCodesGroupBy | DiscountCodesConnectionId | DiscountCodesConnectionCreated_at | DiscountCodesConnectionUpdated_at | DiscountCodesConnectionName | DiscountCodesConnectionDescription | DiscountCodesConnectionStatus_voucher | DiscountCodesConnectionUnique_multiple | DiscountCodesConnectionMultiple_redemptions | DiscountCodesConnectionOne_redemption | DiscountCodesConnectionRedeem_until_usedup | DiscountCodesConnectionSingle_redemption | DiscountCodesConnectionMinimum_order_value | DiscountCodesConnectionValid_from_date_time | DiscountCodesConnectionValid_to_date_time | DiscountCodesConnectionCode_character_length | DiscountCodesConnectionAmount_discount | DiscountCodesConnectionType_of_discount | DiscountCodesConnectionPublished_at | createDiscountCodePayload | updateDiscountCodePayload | deleteDiscountCodePayload | Discount | updateDiscountPayload | deleteDiscountPayload | DpabStore | DpabStoreConnection | DpabStoreAggregator | DpabStoreGroupBy | DpabStoreConnectionId | DpabStoreConnectionCreated_at | DpabStoreConnectionUpdated_at | DpabStoreConnectionTitle | DpabStoreConnectionValue_1 | DpabStoreConnectionValue_2 | DpabStoreConnectionPublished_at | createDpabStorePayload | updateDpabStorePayload | deleteDpabStorePayload | EightProducts | EightProductsConnection | EightProductsAggregator | EightProductsGroupBy | EightProductsConnectionId | EightProductsConnectionCreated_at | EightProductsConnectionUpdated_at | EightProductsConnectionPosition | EightProductsConnectionPublished_at | createEightProductPayload | updateEightProductPayload | deleteEightProductPayload | FavoriteProduct | FavoriteProductConnection | FavoriteProductAggregator | FavoriteProductGroupBy | FavoriteProductConnectionId | FavoriteProductConnectionCreated_at | FavoriteProductConnectionUpdated_at | FavoriteProductConnectionUsers_permissions_user | FavoriteProductConnectionProduct | FavoriteProductConnectionPublished_at | createFavoriteProductPayload | updateFavoriteProductPayload | deleteFavoriteProductPayload | FourIcons | FourIconsConnection | FourIconsAggregator | FourIconsGroupBy | FourIconsConnectionId | FourIconsConnectionCreated_at | FourIconsConnectionUpdated_at | FourIconsConnectionHeader | FourIconsConnectionText | FourIconsConnectionPublished_at | createFourIconPayload | updateFourIconPayload | deleteFourIconPayload | FourProducts | FourProductsConnection | FourProductsAggregator | FourProductsGroupBy | FourProductsConnectionId | FourProductsConnectionCreated_at | FourProductsConnectionUpdated_at | FourProductsConnectionPosition | FourProductsConnectionPublished_at | createFourProductPayload | updateFourProductPayload | deleteFourProductPayload | GiftWrap | GiftWrapConnection | GiftWrapAggregator | GiftWrapGroupBy | GiftWrapConnectionId | GiftWrapConnectionCreated_at | GiftWrapConnectionUpdated_at | GiftWrapConnectionPrice | GiftWrapConnectionName | GiftWrapConnectionText | GiftWrapConnectionSecure | GiftWrapConnectionPublished_at | createGiftWrapPayload | updateGiftWrapPayload | deleteGiftWrapPayload | Inspiration | InspirationConnection | InspirationAggregator | InspirationGroupBy | InspirationConnectionId | InspirationConnectionCreated_at | InspirationConnectionUpdated_at | InspirationConnectionHeader | InspirationConnectionTitle | InspirationConnectionText | InspirationConnectionButton_text | InspirationConnectionUrl | InspirationConnectionImages | InspirationConnectionImage_header | InspirationConnectionImage_title | InspirationConnectionPosition | InspirationConnectionPublished_at | createInspirationPayload | updateInspirationPayload | deleteInspirationPayload | Interieur | InterieurConnection | InterieurAggregator | InterieurGroupBy | InterieurConnectionId | InterieurConnectionCreated_at | InterieurConnectionUpdated_at | InterieurConnectionProductId | InterieurConnectionImages | InterieurConnectionNew_Date_Limit | InterieurConnectionLimited_edition | InterieurConnectionBrand | InterieurConnectionKind | InterieurConnectionName | InterieurConnectionPrice | InterieurConnectionClean_product | InterieurConnectionPublished_at | createInterieurPayload | updateInterieurPayload | deleteInterieurPayload | MagazinPresentation | MagazinPresentationConnection | MagazinPresentationAggregator | MagazinPresentationGroupBy | MagazinPresentationConnectionId | MagazinPresentationConnectionCreated_at | MagazinPresentationConnectionUpdated_at | MagazinPresentationConnectionImages_1 | MagazinPresentationConnectionText_1 | MagazinPresentationConnectionText_2 | MagazinPresentationConnectionImages_2 | MagazinPresentationConnectionPosition | MagazinPresentationConnectionPublished_at | createMagazinPresentationPayload | updateMagazinPresentationPayload | deleteMagazinPresentationPayload | MainAccount | MainAccountConnection | MainAccountAggregator | MainAccountGroupBy | MainAccountConnectionId | MainAccountConnectionCreated_at | MainAccountConnectionUpdated_at | MainAccountConnectionAddresses | MainAccountConnectionUser_data | MainAccountConnectionOrders | MainAccountConnectionWishlist | MainAccountConnectionNewsletter | MainAccountConnectionMy_bookmarks | MainAccountConnectionPublished_at | createMainAccountPayload | updateMainAccountPayload | deleteMainAccountPayload | MeinKonto | MeinKontoConnection | MeinKontoAggregator | MeinKontoGroupBy | MeinKontoConnectionId | MeinKontoConnectionCreated_at | MeinKontoConnectionUpdated_at | MeinKontoConnectionTitle | MeinKontoConnectionUrl | MeinKontoConnectionPublished_at | createMeinKontoPayload | updateMeinKontoPayload | deleteMeinKontoPayload | MenuItem | MenuItemConnection | MenuItemAggregator | MenuItemGroupBy | MenuItemConnectionId | MenuItemConnectionCreated_at | MenuItemConnectionUpdated_at | MenuItemConnectionItem_name | MenuItemConnectionTitle | MenuItemConnectionImages | MenuItemConnectionUrl | MenuItemConnectionPosition | MenuItemConnectionPublished_at | createMenuItemPayload | updateMenuItemPayload | deleteMenuItemPayload | MidFooter | MidFooterConnection | MidFooterAggregator | MidFooterGroupBy | MidFooterConnectionId | MidFooterConnectionCreated_at | MidFooterConnectionUpdated_at | MidFooterConnectionHeader | MidFooterConnectionImages | MidFooterConnectionText_1 | MidFooterConnectionText_2 | MidFooterConnectionText_3 | MidFooterConnectionPublished_at | createMidFooterPayload | updateMidFooterPayload | deleteMidFooterPayload | NewProductLimit | updateNewProductLimitPayload | deleteNewProductLimitPayload | NewsReport | NewsReportConnection | NewsReportAggregator | NewsReportGroupBy | NewsReportConnectionId | NewsReportConnectionCreated_at | NewsReportConnectionUpdated_at | NewsReportConnectionHeader | NewsReportConnectionTitle | NewsReportConnectionText | NewsReportConnectionUrl | NewsReportConnectionLink_text | NewsReportConnectionImages | NewsReportConnectionPosition | NewsReportConnectionPublished_at | createNewsReportPayload | updateNewsReportPayload | deleteNewsReportPayload | NewsletterText | NewsletterTextConnection | NewsletterTextAggregator | NewsletterTextGroupBy | NewsletterTextConnectionId | NewsletterTextConnectionCreated_at | NewsletterTextConnectionUpdated_at | NewsletterTextConnectionText | NewsletterTextConnectionPublished_at | createNewsletterTextPayload | updateNewsletterTextPayload | deleteNewsletterTextPayload | Newsletter | NewsletterConnection | NewsletterAggregator | NewsletterGroupBy | NewsletterConnectionId | NewsletterConnectionCreated_at | NewsletterConnectionUpdated_at | NewsletterConnectionSubject | NewsletterConnectionHTML_describe | NewsletterConnectionPublished_at | createNewsletterPayload | updateNewsletterPayload | deleteNewsletterPayload | PageHeader | PageHeaderConnection | PageHeaderAggregator | PageHeaderGroupBy | PageHeaderConnectionId | PageHeaderConnectionCreated_at | PageHeaderConnectionUpdated_at | PageHeaderConnectionDescribe_HTML_CSS | PageHeaderConnectionPosition | PageHeaderConnectionPublished_at | createPageHeaderPayload | updatePageHeaderPayload | deletePageHeaderPayload | Parfums | ParfumsConnection | ParfumsAggregator | ParfumsGroupBy | ParfumsConnectionId | ParfumsConnectionCreated_at | ParfumsConnectionUpdated_at | ParfumsConnectionProductId | ParfumsConnectionImages | ParfumsConnectionNew_Date_Limit | ParfumsConnectionLimited_edition | ParfumsConnectionBrand | ParfumsConnectionKind | ParfumsConnectionName | ParfumsConnectionPrice | ParfumsConnectionClean_product | ParfumsConnectionPublished_at | createParfumPayload | updateParfumPayload | deleteParfumPayload | PermanentDiscount | updatePermanentDiscountPayload | deletePermanentDiscountPayload | ProductWithLeftText | ProductWithLeftTextConnection | ProductWithLeftTextAggregator | ProductWithLeftTextGroupBy | ProductWithLeftTextConnectionId | ProductWithLeftTextConnectionCreated_at | ProductWithLeftTextConnectionUpdated_at | ProductWithLeftTextConnectionHeader | ProductWithLeftTextConnectionTitle | ProductWithLeftTextConnectionText | ProductWithLeftTextConnectionButton_text | ProductWithLeftTextConnectionUrl | ProductWithLeftTextConnectionPosition | ProductWithLeftTextConnectionPublished_at | createProductWithLeftTextPayload | updateProductWithLeftTextPayload | deleteProductWithLeftTextPayload | Products | ProductsConnection | ProductsAggregator | ProductsGroupBy | ProductsConnectionId | ProductsConnectionCreated_at | ProductsConnectionUpdated_at | ProductsConnectionClean_product | ProductsConnectionBrand | ProductsConnectionFor_sale_count | ProductsConnectionUnit | ProductsConnectionDiscount | ProductsConnectionType_test | ProductsConnectionCategory | ProductsConnectionSub_category | ProductsConnectionMenu_item | ProductsConnectionName | ProductsConnectionMagazin_presentation | ProductsConnectionKind | ProductsConnectionNew_Date_Limit | ProductsConnectionVideo | ProductsConnectionPrice | ProductsConnectionLimited_edition | ProductsConnectionVideo_description | ProductsConnectionVideo_status | ProductsConnectionVideo_name | ProductsConnectionPublished_at | createProductPayload | updateProductPayload | deleteProductPayload | SectionUnderNavbar | SectionUnderNavbarConnection | SectionUnderNavbarAggregator | SectionUnderNavbarGroupBy | SectionUnderNavbarConnectionId | SectionUnderNavbarConnectionCreated_at | SectionUnderNavbarConnectionUpdated_at | SectionUnderNavbarConnectionHeader | SectionUnderNavbarConnectionTitle | SectionUnderNavbarConnectionButton_text | SectionUnderNavbarConnectionUrl | SectionUnderNavbarConnectionImages | SectionUnderNavbarConnectionPosition | SectionUnderNavbarConnectionPublished_at | createSectionUnderNavbarPayload | updateSectionUnderNavbarPayload | deleteSectionUnderNavbarPayload | ShopPageLargeText | ShopPageLargeTextConnection | ShopPageLargeTextAggregator | ShopPageLargeTextGroupBy | ShopPageLargeTextConnectionId | ShopPageLargeTextConnectionCreated_at | ShopPageLargeTextConnectionUpdated_at | ShopPageLargeTextConnectionHeader | ShopPageLargeTextConnectionText | ShopPageLargeTextConnectionPublished_at | createShopPageLargeTextPayload | updateShopPageLargeTextPayload | deleteShopPageLargeTextPayload | ShoppingBasketRecommendation | ShoppingBasketRecommendationConnection | ShoppingBasketRecommendationAggregator | ShoppingBasketRecommendationGroupBy | ShoppingBasketRecommendationConnectionId | ShoppingBasketRecommendationConnectionCreated_at | ShoppingBasketRecommendationConnectionUpdated_at | ShoppingBasketRecommendationConnectionTo | ShoppingBasketRecommendationConnectionFrom | ShoppingBasketRecommendationConnectionCurrent_shopping_basket_product_id | ShoppingBasketRecommendationConnectionPublished_at | createShoppingBasketRecommendationPayload | updateShoppingBasketRecommendationPayload | deleteShoppingBasketRecommendationPayload | ShoppingBasket | ShoppingBasketConnection | ShoppingBasketAggregator | ShoppingBasketGroupBy | ShoppingBasketConnectionId | ShoppingBasketConnectionCreated_at | ShoppingBasketConnectionUpdated_at | ShoppingBasketConnectionUsers_permissions_user | ShoppingBasketConnectionProduct | ShoppingBasketConnectionGift_wrap | ShoppingBasketConnectionType_test | ShoppingBasketConnectionQuantity | ShoppingBasketConnectionPublished_at | createShoppingBasketPayload | updateShoppingBasketPayload | deleteShoppingBasketPayload | StairSection | StairSectionConnection | StairSectionAggregator | StairSectionGroupBy | StairSectionConnectionId | StairSectionConnectionCreated_at | StairSectionConnectionUpdated_at | StairSectionConnectionImage | StairSectionConnectionHeader | StairSectionConnectionText | StairSectionConnectionDate | StairSectionConnectionPosition | StairSectionConnectionPublished_at | createStairSectionPayload | updateStairSectionPayload | deleteStairSectionPayload | Style | StyleConnection | StyleAggregator | StyleGroupBy | StyleConnectionId | StyleConnectionCreated_at | StyleConnectionUpdated_at | StyleConnectionImages | StyleConnectionText | StyleConnectionLink_text | StyleConnectionLink | StyleConnectionPublished_at | createStylePayload | updateStylePayload | deleteStylePayload | SubCategory | SubCategoryConnection | SubCategoryAggregator | SubCategoryGroupBy | SubCategoryConnectionId | SubCategoryConnectionCreated_at | SubCategoryConnectionUpdated_at | SubCategoryConnectionSubCategoryName | SubCategoryConnectionPublished_at | createSubCategoryPayload | updateSubCategoryPayload | deleteSubCategoryPayload | TopOfTheFooter | TopOfTheFooterConnection | TopOfTheFooterAggregator | TopOfTheFooterGroupBy | TopOfTheFooterConnectionId | TopOfTheFooterConnectionCreated_at | TopOfTheFooterConnectionUpdated_at | TopOfTheFooterConnectionImages | TopOfTheFooterConnectionHeader | TopOfTheFooterConnectionText | TopOfTheFooterConnectionPublished_at | createTopOfTheFooterPayload | updateTopOfTheFooterPayload | deleteTopOfTheFooterPayload | TypeTest | TypeTestConnection | TypeTestAggregator | TypeTestAggregatorSum | TypeTestAggregatorAvg | TypeTestAggregatorMin | TypeTestAggregatorMax | TypeTestGroupBy | TypeTestConnectionId | TypeTestConnectionCreated_at | TypeTestConnectionUpdated_at | TypeTestConnectionBrand | TypeTestConnectionPrice | TypeTestConnectionSize | TypeTestConnectionQuantity | TypeTestConnectionProduct | TypeTestConnectionImages | TypeTestConnectionPublished_at | createTypeTestPayload | updateTypeTestPayload | deleteTypeTestPayload | UserNewsletter | UserNewsletterConnection | UserNewsletterAggregator | UserNewsletterGroupBy | UserNewsletterConnectionId | UserNewsletterConnectionCreated_at | UserNewsletterConnectionUpdated_at | UserNewsletterConnectionFirst_name | UserNewsletterConnectionSurname | UserNewsletterConnectionGender | UserNewsletterConnectionEmail | UserNewsletterConnectionPublished_at | createUserNewsletterPayload | updateUserNewsletterPayload | deleteUserNewsletterPayload | Videos | VideosConnection | VideosAggregator | VideosGroupBy | VideosConnectionId | VideosConnectionCreated_at | VideosConnectionUpdated_at | VideosConnectionVideo_status | VideosConnectionVideo_name | VideosConnectionDescription | VideosConnectionUrl | VideosConnectionVideo_id | VideosConnectionBookmark | VideosConnectionPublished_at | createVideoPayload | updateVideoPayload | deleteVideoPayload | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionRegular_customer | createUserPayload | updateUserPayload | deleteUserPayload

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  beauty(id: ID!, publicationState: PublicationState): Beauty
  beauties(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Beauty]
  beautiesConnection(sort: String, limit: Int, start: Int, where: JSON): BeautyConnection
  bookmark(id: ID!, publicationState: PublicationState): Bookmark
  bookmarks(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Bookmark]
  bookmarksConnection(sort: String, limit: Int, start: Int, where: JSON): BookmarkConnection
  category(id: ID!, publicationState: PublicationState): Category
  categories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Category]
  categoriesConnection(sort: String, limit: Int, start: Int, where: JSON): CategoryConnection
  collectionShop(id: ID!, publicationState: PublicationState): CollectionShop
  collectionShops(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [CollectionShop]
  collectionShopsConnection(sort: String, limit: Int, start: Int, where: JSON): CollectionShopConnection
  contactDetail(id: ID!, publicationState: PublicationState): ContactDetails
  contactDetails(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ContactDetails]
  contactDetailsConnection(sort: String, limit: Int, start: Int, where: JSON): ContactDetailsConnection
  contact(id: ID!, publicationState: PublicationState): Contact
  contacts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Contact]
  contactsConnection(sort: String, limit: Int, start: Int, where: JSON): ContactConnection
  discountCode(id: ID!, publicationState: PublicationState): DiscountCodes
  discountCodes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DiscountCodes]
  discountCodesConnection(sort: String, limit: Int, start: Int, where: JSON): DiscountCodesConnection
  discount(publicationState: PublicationState): Discount
  dpabStore(id: ID!, publicationState: PublicationState): DpabStore
  dpabStores(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DpabStore]
  dpabStoresConnection(sort: String, limit: Int, start: Int, where: JSON): DpabStoreConnection
  eightProduct(id: ID!, publicationState: PublicationState): EightProducts
  eightProducts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [EightProducts]
  eightProductsConnection(sort: String, limit: Int, start: Int, where: JSON): EightProductsConnection
  favoriteProduct(id: ID!, publicationState: PublicationState): FavoriteProduct
  favoriteProducts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [FavoriteProduct]
  favoriteProductsConnection(sort: String, limit: Int, start: Int, where: JSON): FavoriteProductConnection
  fourIcon(id: ID!, publicationState: PublicationState): FourIcons
  fourIcons(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [FourIcons]
  fourIconsConnection(sort: String, limit: Int, start: Int, where: JSON): FourIconsConnection
  fourProduct(id: ID!, publicationState: PublicationState): FourProducts
  fourProducts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [FourProducts]
  fourProductsConnection(sort: String, limit: Int, start: Int, where: JSON): FourProductsConnection
  giftWrap(id: ID!, publicationState: PublicationState): GiftWrap
  giftWraps(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [GiftWrap]
  giftWrapsConnection(sort: String, limit: Int, start: Int, where: JSON): GiftWrapConnection
  inspiration(id: ID!, publicationState: PublicationState): Inspiration
  inspirations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Inspiration]
  inspirationsConnection(sort: String, limit: Int, start: Int, where: JSON): InspirationConnection
  interieur(id: ID!, publicationState: PublicationState): Interieur
  interieurs(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Interieur]
  interieursConnection(sort: String, limit: Int, start: Int, where: JSON): InterieurConnection
  magazinPresentation(id: ID!, publicationState: PublicationState): MagazinPresentation
  magazinPresentations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MagazinPresentation]
  magazinPresentationsConnection(sort: String, limit: Int, start: Int, where: JSON): MagazinPresentationConnection
  mainAccount(id: ID!, publicationState: PublicationState): MainAccount
  mainAccounts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MainAccount]
  mainAccountsConnection(sort: String, limit: Int, start: Int, where: JSON): MainAccountConnection
  meinKonto(id: ID!, publicationState: PublicationState): MeinKonto
  meinKontos(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MeinKonto]
  meinKontosConnection(sort: String, limit: Int, start: Int, where: JSON): MeinKontoConnection
  menuItem(id: ID!, publicationState: PublicationState): MenuItem
  menuItems(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MenuItem]
  menuItemsConnection(sort: String, limit: Int, start: Int, where: JSON): MenuItemConnection
  midFooter(id: ID!, publicationState: PublicationState): MidFooter
  midFooters(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MidFooter]
  midFootersConnection(sort: String, limit: Int, start: Int, where: JSON): MidFooterConnection
  newProductLimit(publicationState: PublicationState): NewProductLimit
  newsReport(id: ID!, publicationState: PublicationState): NewsReport
  newsReports(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [NewsReport]
  newsReportsConnection(sort: String, limit: Int, start: Int, where: JSON): NewsReportConnection
  newsletterText(id: ID!, publicationState: PublicationState): NewsletterText
  newsletterTexts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [NewsletterText]
  newsletterTextsConnection(sort: String, limit: Int, start: Int, where: JSON): NewsletterTextConnection
  newsletter(id: ID!, publicationState: PublicationState): Newsletter
  newsletters(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Newsletter]
  newslettersConnection(sort: String, limit: Int, start: Int, where: JSON): NewsletterConnection
  pageHeader(id: ID!, publicationState: PublicationState): PageHeader
  pageHeaders(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [PageHeader]
  pageHeadersConnection(sort: String, limit: Int, start: Int, where: JSON): PageHeaderConnection
  parfum(id: ID!, publicationState: PublicationState): Parfums
  parfums(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Parfums]
  parfumsConnection(sort: String, limit: Int, start: Int, where: JSON): ParfumsConnection
  permanentDiscount(publicationState: PublicationState): PermanentDiscount
  productWithLeftText(id: ID!, publicationState: PublicationState): ProductWithLeftText
  productWithLeftTexts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProductWithLeftText]
  productWithLeftTextsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductWithLeftTextConnection
  product(id: ID!, publicationState: PublicationState): Products
  products(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Products]
  productsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductsConnection
  sectionUnderNavbar(id: ID!, publicationState: PublicationState): SectionUnderNavbar
  sectionUnderNavbars(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [SectionUnderNavbar]
  sectionUnderNavbarsConnection(sort: String, limit: Int, start: Int, where: JSON): SectionUnderNavbarConnection
  shopPageLargeText(id: ID!, publicationState: PublicationState): ShopPageLargeText
  shopPageLargeTexts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShopPageLargeText]
  shopPageLargeTextsConnection(sort: String, limit: Int, start: Int, where: JSON): ShopPageLargeTextConnection
  shoppingBasketRecommendation(id: ID!, publicationState: PublicationState): ShoppingBasketRecommendation
  shoppingBasketRecommendations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShoppingBasketRecommendation]
  shoppingBasketRecommendationsConnection(sort: String, limit: Int, start: Int, where: JSON): ShoppingBasketRecommendationConnection
  shoppingBasket(id: ID!, publicationState: PublicationState): ShoppingBasket
  shoppingBaskets(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShoppingBasket]
  shoppingBasketsConnection(sort: String, limit: Int, start: Int, where: JSON): ShoppingBasketConnection
  stairSection(id: ID!, publicationState: PublicationState): StairSection
  stairSections(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [StairSection]
  stairSectionsConnection(sort: String, limit: Int, start: Int, where: JSON): StairSectionConnection
  style(id: ID!, publicationState: PublicationState): Style
  styles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Style]
  stylesConnection(sort: String, limit: Int, start: Int, where: JSON): StyleConnection
  subCategory(id: ID!, publicationState: PublicationState): SubCategory
  subCategories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [SubCategory]
  subCategoriesConnection(sort: String, limit: Int, start: Int, where: JSON): SubCategoryConnection
  topOfTheFooter(id: ID!, publicationState: PublicationState): TopOfTheFooter
  topOfTheFooters(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [TopOfTheFooter]
  topOfTheFootersConnection(sort: String, limit: Int, start: Int, where: JSON): TopOfTheFooterConnection
  typeTest(id: ID!, publicationState: PublicationState): TypeTest
  typeTests(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [TypeTest]
  typeTestsConnection(sort: String, limit: Int, start: Int, where: JSON): TypeTestConnection
  userNewsletter(id: ID!, publicationState: PublicationState): UserNewsletter
  userNewsletters(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UserNewsletter]
  userNewslettersConnection(sort: String, limit: Int, start: Int, where: JSON): UserNewsletterConnection
  video(id: ID!, publicationState: PublicationState): Videos
  videos(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Videos]
  videosConnection(sort: String, limit: Int, start: Int, where: JSON): VideosConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

type Mutation {
  createBeauty(input: createBeautyInput): createBeautyPayload
  updateBeauty(input: updateBeautyInput): updateBeautyPayload
  deleteBeauty(input: deleteBeautyInput): deleteBeautyPayload
  createBookmark(input: createBookmarkInput): createBookmarkPayload
  updateBookmark(input: updateBookmarkInput): updateBookmarkPayload
  deleteBookmark(input: deleteBookmarkInput): deleteBookmarkPayload
  createCategory(input: createCategoryInput): createCategoryPayload
  updateCategory(input: updateCategoryInput): updateCategoryPayload
  deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
  createCollectionShop(input: createCollectionShopInput): createCollectionShopPayload
  updateCollectionShop(input: updateCollectionShopInput): updateCollectionShopPayload
  deleteCollectionShop(input: deleteCollectionShopInput): deleteCollectionShopPayload
  createContactDetail(input: createContactDetailInput): createContactDetailPayload
  updateContactDetail(input: updateContactDetailInput): updateContactDetailPayload
  deleteContactDetail(input: deleteContactDetailInput): deleteContactDetailPayload
  createContact(input: createContactInput): createContactPayload
  updateContact(input: updateContactInput): updateContactPayload
  deleteContact(input: deleteContactInput): deleteContactPayload
  createDiscountCode(input: createDiscountCodeInput): createDiscountCodePayload
  updateDiscountCode(input: updateDiscountCodeInput): updateDiscountCodePayload
  deleteDiscountCode(input: deleteDiscountCodeInput): deleteDiscountCodePayload
  updateDiscount(input: updateDiscountInput): updateDiscountPayload
  deleteDiscount: deleteDiscountPayload
  createDpabStore(input: createDpabStoreInput): createDpabStorePayload
  updateDpabStore(input: updateDpabStoreInput): updateDpabStorePayload
  deleteDpabStore(input: deleteDpabStoreInput): deleteDpabStorePayload
  createEightProduct(input: createEightProductInput): createEightProductPayload
  updateEightProduct(input: updateEightProductInput): updateEightProductPayload
  deleteEightProduct(input: deleteEightProductInput): deleteEightProductPayload
  createFavoriteProduct(input: createFavoriteProductInput): createFavoriteProductPayload
  updateFavoriteProduct(input: updateFavoriteProductInput): updateFavoriteProductPayload
  deleteFavoriteProduct(input: deleteFavoriteProductInput): deleteFavoriteProductPayload
  createFourIcon(input: createFourIconInput): createFourIconPayload
  updateFourIcon(input: updateFourIconInput): updateFourIconPayload
  deleteFourIcon(input: deleteFourIconInput): deleteFourIconPayload
  createFourProduct(input: createFourProductInput): createFourProductPayload
  updateFourProduct(input: updateFourProductInput): updateFourProductPayload
  deleteFourProduct(input: deleteFourProductInput): deleteFourProductPayload
  createGiftWrap(input: createGiftWrapInput): createGiftWrapPayload
  updateGiftWrap(input: updateGiftWrapInput): updateGiftWrapPayload
  deleteGiftWrap(input: deleteGiftWrapInput): deleteGiftWrapPayload
  createInspiration(input: createInspirationInput): createInspirationPayload
  updateInspiration(input: updateInspirationInput): updateInspirationPayload
  deleteInspiration(input: deleteInspirationInput): deleteInspirationPayload
  createInterieur(input: createInterieurInput): createInterieurPayload
  updateInterieur(input: updateInterieurInput): updateInterieurPayload
  deleteInterieur(input: deleteInterieurInput): deleteInterieurPayload
  createMagazinPresentation(input: createMagazinPresentationInput): createMagazinPresentationPayload
  updateMagazinPresentation(input: updateMagazinPresentationInput): updateMagazinPresentationPayload
  deleteMagazinPresentation(input: deleteMagazinPresentationInput): deleteMagazinPresentationPayload
  createMainAccount(input: createMainAccountInput): createMainAccountPayload
  updateMainAccount(input: updateMainAccountInput): updateMainAccountPayload
  deleteMainAccount(input: deleteMainAccountInput): deleteMainAccountPayload
  createMeinKonto(input: createMeinKontoInput): createMeinKontoPayload
  updateMeinKonto(input: updateMeinKontoInput): updateMeinKontoPayload
  deleteMeinKonto(input: deleteMeinKontoInput): deleteMeinKontoPayload
  createMenuItem(input: createMenuItemInput): createMenuItemPayload
  updateMenuItem(input: updateMenuItemInput): updateMenuItemPayload
  deleteMenuItem(input: deleteMenuItemInput): deleteMenuItemPayload
  createMidFooter(input: createMidFooterInput): createMidFooterPayload
  updateMidFooter(input: updateMidFooterInput): updateMidFooterPayload
  deleteMidFooter(input: deleteMidFooterInput): deleteMidFooterPayload
  updateNewProductLimit(input: updateNewProductLimitInput): updateNewProductLimitPayload
  deleteNewProductLimit: deleteNewProductLimitPayload
  createNewsReport(input: createNewsReportInput): createNewsReportPayload
  updateNewsReport(input: updateNewsReportInput): updateNewsReportPayload
  deleteNewsReport(input: deleteNewsReportInput): deleteNewsReportPayload
  createNewsletterText(input: createNewsletterTextInput): createNewsletterTextPayload
  updateNewsletterText(input: updateNewsletterTextInput): updateNewsletterTextPayload
  deleteNewsletterText(input: deleteNewsletterTextInput): deleteNewsletterTextPayload
  createNewsletter(input: createNewsletterInput): createNewsletterPayload
  updateNewsletter(input: updateNewsletterInput): updateNewsletterPayload
  deleteNewsletter(input: deleteNewsletterInput): deleteNewsletterPayload
  createPageHeader(input: createPageHeaderInput): createPageHeaderPayload
  updatePageHeader(input: updatePageHeaderInput): updatePageHeaderPayload
  deletePageHeader(input: deletePageHeaderInput): deletePageHeaderPayload
  createParfum(input: createParfumInput): createParfumPayload
  updateParfum(input: updateParfumInput): updateParfumPayload
  deleteParfum(input: deleteParfumInput): deleteParfumPayload
  updatePermanentDiscount(input: updatePermanentDiscountInput): updatePermanentDiscountPayload
  deletePermanentDiscount: deletePermanentDiscountPayload
  createProductWithLeftText(input: createProductWithLeftTextInput): createProductWithLeftTextPayload
  updateProductWithLeftText(input: updateProductWithLeftTextInput): updateProductWithLeftTextPayload
  deleteProductWithLeftText(input: deleteProductWithLeftTextInput): deleteProductWithLeftTextPayload
  createProduct(input: createProductInput): createProductPayload
  updateProduct(input: updateProductInput): updateProductPayload
  deleteProduct(input: deleteProductInput): deleteProductPayload
  createSectionUnderNavbar(input: createSectionUnderNavbarInput): createSectionUnderNavbarPayload
  updateSectionUnderNavbar(input: updateSectionUnderNavbarInput): updateSectionUnderNavbarPayload
  deleteSectionUnderNavbar(input: deleteSectionUnderNavbarInput): deleteSectionUnderNavbarPayload
  createShopPageLargeText(input: createShopPageLargeTextInput): createShopPageLargeTextPayload
  updateShopPageLargeText(input: updateShopPageLargeTextInput): updateShopPageLargeTextPayload
  deleteShopPageLargeText(input: deleteShopPageLargeTextInput): deleteShopPageLargeTextPayload
  createShoppingBasketRecommendation(input: createShoppingBasketRecommendationInput): createShoppingBasketRecommendationPayload
  updateShoppingBasketRecommendation(input: updateShoppingBasketRecommendationInput): updateShoppingBasketRecommendationPayload
  deleteShoppingBasketRecommendation(input: deleteShoppingBasketRecommendationInput): deleteShoppingBasketRecommendationPayload
  createShoppingBasket(input: createShoppingBasketInput): createShoppingBasketPayload
  updateShoppingBasket(input: updateShoppingBasketInput): updateShoppingBasketPayload
  deleteShoppingBasket(input: deleteShoppingBasketInput): deleteShoppingBasketPayload
  createStairSection(input: createStairSectionInput): createStairSectionPayload
  updateStairSection(input: updateStairSectionInput): updateStairSectionPayload
  deleteStairSection(input: deleteStairSectionInput): deleteStairSectionPayload
  createStyle(input: createStyleInput): createStylePayload
  updateStyle(input: updateStyleInput): updateStylePayload
  deleteStyle(input: deleteStyleInput): deleteStylePayload
  createSubCategory(input: createSubCategoryInput): createSubCategoryPayload
  updateSubCategory(input: updateSubCategoryInput): updateSubCategoryPayload
  deleteSubCategory(input: deleteSubCategoryInput): deleteSubCategoryPayload
  createTopOfTheFooter(input: createTopOfTheFooterInput): createTopOfTheFooterPayload
  updateTopOfTheFooter(input: updateTopOfTheFooterInput): updateTopOfTheFooterPayload
  deleteTopOfTheFooter(input: deleteTopOfTheFooterInput): deleteTopOfTheFooterPayload
  createTypeTest(input: createTypeTestInput): createTypeTestPayload
  updateTypeTest(input: updateTypeTestInput): updateTypeTestPayload
  deleteTypeTest(input: deleteTypeTestInput): deleteTypeTestPayload
  createUserNewsletter(input: createUserNewsletterInput): createUserNewsletterPayload
  updateUserNewsletter(input: updateUserNewsletterInput): updateUserNewsletterPayload
  deleteUserNewsletter(input: deleteUserNewsletterInput): deleteUserNewsletterPayload
  createVideo(input: createVideoInput): createVideoPayload
  updateVideo(input: updateVideoInput): updateVideoPayload
  deleteVideo(input: deleteVideoInput): deleteVideoPayload

  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload
