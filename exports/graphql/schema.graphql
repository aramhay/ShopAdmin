input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type Category {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  CategoryName: String!
  published_at: DateTime
  sub_categories(sort: String, limit: Int, start: Int, where: JSON): [SubCategory]
}

type CategoryConnection {
  values: [Category]
  groupBy: CategoryGroupBy
  aggregate: CategoryAggregator
}

type CategoryAggregator {
  count: Int
  totalCount: Int
}

type CategoryGroupBy {
  id: [CategoryConnectionId]
  created_at: [CategoryConnectionCreated_at]
  updated_at: [CategoryConnectionUpdated_at]
  CategoryName: [CategoryConnectionCategoryName]
  published_at: [CategoryConnectionPublished_at]
}

type CategoryConnectionId {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionCreated_at {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionUpdated_at {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionCategoryName {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionPublished_at {
  key: DateTime
  connection: CategoryConnection
}

input CategoryInput {
  CategoryName: String!
  sub_categories: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCategoryInput {
  CategoryName: String
  sub_categories: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCategoryInput {
  data: CategoryInput
}

type createCategoryPayload {
  category: Category
}

input updateCategoryInput {
  where: InputID
  data: editCategoryInput
}

type updateCategoryPayload {
  category: Category
}

input deleteCategoryInput {
  where: InputID
}

type deleteCategoryPayload {
  category: Category
}

enum ENUM_COLLECTIONSHOP_POSITION {
  HomePageLeft
  HomePageRight
  HerrenPageLeft
  HerrenPageRight
}

type CollectionShop {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  url: String
  images: UploadFile
  Link_text: String
  position: ENUM_COLLECTIONSHOP_POSITION!
  published_at: DateTime
}

type CollectionShopConnection {
  values: [CollectionShop]
  groupBy: CollectionShopGroupBy
  aggregate: CollectionShopAggregator
}

type CollectionShopAggregator {
  count: Int
  totalCount: Int
}

type CollectionShopGroupBy {
  id: [CollectionShopConnectionId]
  created_at: [CollectionShopConnectionCreated_at]
  updated_at: [CollectionShopConnectionUpdated_at]
  header: [CollectionShopConnectionHeader]
  title: [CollectionShopConnectionTitle]
  url: [CollectionShopConnectionUrl]
  images: [CollectionShopConnectionImages]
  Link_text: [CollectionShopConnectionLink_text]
  position: [CollectionShopConnectionPosition]
  published_at: [CollectionShopConnectionPublished_at]
}

type CollectionShopConnectionId {
  key: ID
  connection: CollectionShopConnection
}

type CollectionShopConnectionCreated_at {
  key: DateTime
  connection: CollectionShopConnection
}

type CollectionShopConnectionUpdated_at {
  key: DateTime
  connection: CollectionShopConnection
}

type CollectionShopConnectionHeader {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionTitle {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionUrl {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionImages {
  key: ID
  connection: CollectionShopConnection
}

type CollectionShopConnectionLink_text {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionPosition {
  key: String
  connection: CollectionShopConnection
}

type CollectionShopConnectionPublished_at {
  key: DateTime
  connection: CollectionShopConnection
}

input CollectionShopInput {
  header: String
  title: String
  url: String
  images: ID
  Link_text: String
  position: ENUM_COLLECTIONSHOP_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCollectionShopInput {
  header: String
  title: String
  url: String
  images: ID
  Link_text: String
  position: ENUM_COLLECTIONSHOP_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCollectionShopInput {
  data: CollectionShopInput
}

type createCollectionShopPayload {
  collectionShop: CollectionShop
}

input updateCollectionShopInput {
  where: InputID
  data: editCollectionShopInput
}

type updateCollectionShopPayload {
  collectionShop: CollectionShop
}

input deleteCollectionShopInput {
  where: InputID
}

type deleteCollectionShopPayload {
  collectionShop: CollectionShop
}

type ContactDetails {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  email: String
  phone_number: String
  published_at: DateTime
}

type ContactDetailsConnection {
  values: [ContactDetails]
  groupBy: ContactDetailsGroupBy
  aggregate: ContactDetailsAggregator
}

type ContactDetailsAggregator {
  count: Int
  totalCount: Int
}

type ContactDetailsGroupBy {
  id: [ContactDetailsConnectionId]
  created_at: [ContactDetailsConnectionCreated_at]
  updated_at: [ContactDetailsConnectionUpdated_at]
  email: [ContactDetailsConnectionEmail]
  phone_number: [ContactDetailsConnectionPhone_number]
  published_at: [ContactDetailsConnectionPublished_at]
}

type ContactDetailsConnectionId {
  key: ID
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionCreated_at {
  key: DateTime
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionUpdated_at {
  key: DateTime
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionEmail {
  key: String
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionPhone_number {
  key: String
  connection: ContactDetailsConnection
}

type ContactDetailsConnectionPublished_at {
  key: DateTime
  connection: ContactDetailsConnection
}

input ContactDetailInput {
  email: String
  phone_number: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editContactDetailInput {
  email: String
  phone_number: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createContactDetailInput {
  data: ContactDetailInput
}

type createContactDetailPayload {
  contactDetail: ContactDetails
}

input updateContactDetailInput {
  where: InputID
  data: editContactDetailInput
}

type updateContactDetailPayload {
  contactDetail: ContactDetails
}

input deleteContactDetailInput {
  where: InputID
}

type deleteContactDetailPayload {
  contactDetail: ContactDetails
}

type Contact {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  value: String
  published_at: DateTime
}

type ContactConnection {
  values: [Contact]
  groupBy: ContactGroupBy
  aggregate: ContactAggregator
}

type ContactAggregator {
  count: Int
  totalCount: Int
}

type ContactGroupBy {
  id: [ContactConnectionId]
  created_at: [ContactConnectionCreated_at]
  updated_at: [ContactConnectionUpdated_at]
  title: [ContactConnectionTitle]
  value: [ContactConnectionValue]
  published_at: [ContactConnectionPublished_at]
}

type ContactConnectionId {
  key: ID
  connection: ContactConnection
}

type ContactConnectionCreated_at {
  key: DateTime
  connection: ContactConnection
}

type ContactConnectionUpdated_at {
  key: DateTime
  connection: ContactConnection
}

type ContactConnectionTitle {
  key: String
  connection: ContactConnection
}

type ContactConnectionValue {
  key: String
  connection: ContactConnection
}

type ContactConnectionPublished_at {
  key: DateTime
  connection: ContactConnection
}

input ContactInput {
  title: String
  value: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editContactInput {
  title: String
  value: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createContactInput {
  data: ContactInput
}

type createContactPayload {
  contact: Contact
}

input updateContactInput {
  where: InputID
  data: editContactInput
}

type updateContactPayload {
  contact: Contact
}

input deleteContactInput {
  where: InputID
}

type deleteContactPayload {
  contact: Contact
}

enum ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT {
  prozentual
  absolut
  Stuck
  Versand
}

type DiscountCodes {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  Description: String
  status_voucher: Boolean
  unique_multiple: Boolean
  multiple_redemptions: Boolean
  one_redemption: Boolean
  redeem_until_usedup: JSON
  single_redemption: JSON
  Minimum_order_value: Long
  valid_from_date_time: DateTime
  Valid_to_date_time: DateTime
  code_character_length: Long
  amount_discount: Long
  type_of_discount: ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT
  published_at: DateTime
  products(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type DiscountCodesConnection {
  values: [DiscountCodes]
  groupBy: DiscountCodesGroupBy
  aggregate: DiscountCodesAggregator
}

type DiscountCodesAggregator {
  count: Int
  totalCount: Int
}

type DiscountCodesGroupBy {
  id: [DiscountCodesConnectionId]
  created_at: [DiscountCodesConnectionCreated_at]
  updated_at: [DiscountCodesConnectionUpdated_at]
  Name: [DiscountCodesConnectionName]
  Description: [DiscountCodesConnectionDescription]
  status_voucher: [DiscountCodesConnectionStatus_voucher]
  unique_multiple: [DiscountCodesConnectionUnique_multiple]
  multiple_redemptions: [DiscountCodesConnectionMultiple_redemptions]
  one_redemption: [DiscountCodesConnectionOne_redemption]
  redeem_until_usedup: [DiscountCodesConnectionRedeem_until_usedup]
  single_redemption: [DiscountCodesConnectionSingle_redemption]
  Minimum_order_value: [DiscountCodesConnectionMinimum_order_value]
  valid_from_date_time: [DiscountCodesConnectionValid_from_date_time]
  Valid_to_date_time: [DiscountCodesConnectionValid_to_date_time]
  code_character_length: [DiscountCodesConnectionCode_character_length]
  amount_discount: [DiscountCodesConnectionAmount_discount]
  type_of_discount: [DiscountCodesConnectionType_of_discount]
  published_at: [DiscountCodesConnectionPublished_at]
}

type DiscountCodesConnectionId {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionCreated_at {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionUpdated_at {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionName {
  key: String
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionDescription {
  key: String
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionStatus_voucher {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionUnique_multiple {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionMultiple_redemptions {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionOne_redemption {
  key: Boolean
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionRedeem_until_usedup {
  key: JSON
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionSingle_redemption {
  key: JSON
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionMinimum_order_value {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionValid_from_date_time {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionValid_to_date_time {
  key: DateTime
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionCode_character_length {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionAmount_discount {
  key: ID
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionType_of_discount {
  key: String
  connection: DiscountCodesConnection
}

type DiscountCodesConnectionPublished_at {
  key: DateTime
  connection: DiscountCodesConnection
}

input DiscountCodeInput {
  Name: String
  Description: String
  status_voucher: Boolean
  unique_multiple: Boolean
  multiple_redemptions: Boolean
  one_redemption: Boolean
  redeem_until_usedup: JSON
  single_redemption: JSON
  Minimum_order_value: Long
  valid_from_date_time: DateTime
  Valid_to_date_time: DateTime
  code_character_length: Long
  amount_discount: Long
  type_of_discount: ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDiscountCodeInput {
  Name: String
  Description: String
  status_voucher: Boolean
  unique_multiple: Boolean
  multiple_redemptions: Boolean
  one_redemption: Boolean
  redeem_until_usedup: JSON
  single_redemption: JSON
  Minimum_order_value: Long
  valid_from_date_time: DateTime
  Valid_to_date_time: DateTime
  code_character_length: Long
  amount_discount: Long
  type_of_discount: ENUM_DISCOUNTCODES_TYPE_OF_DISCOUNT
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDiscountCodeInput {
  data: DiscountCodeInput
}

type createDiscountCodePayload {
  discountCode: DiscountCodes
}

input updateDiscountCodeInput {
  where: InputID
  data: editDiscountCodeInput
}

type updateDiscountCodePayload {
  discountCode: DiscountCodes
}

input deleteDiscountCodeInput {
  where: InputID
}

type deleteDiscountCodePayload {
  discountCode: DiscountCodes
}

type Discount {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  discount: Float
  minprice: Float
  published_at: DateTime
}

input DiscountInput {
  discount: Float
  minprice: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDiscountInput {
  discount: Float
  minprice: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateDiscountInput {
  data: editDiscountInput
}

type updateDiscountPayload {
  discount: Discount
}

type deleteDiscountPayload {
  discount: Discount
}

type DpabStore {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  value_1: String
  value_2: String
  published_at: DateTime
}

type DpabStoreConnection {
  values: [DpabStore]
  groupBy: DpabStoreGroupBy
  aggregate: DpabStoreAggregator
}

type DpabStoreAggregator {
  count: Int
  totalCount: Int
}

type DpabStoreGroupBy {
  id: [DpabStoreConnectionId]
  created_at: [DpabStoreConnectionCreated_at]
  updated_at: [DpabStoreConnectionUpdated_at]
  title: [DpabStoreConnectionTitle]
  value_1: [DpabStoreConnectionValue_1]
  value_2: [DpabStoreConnectionValue_2]
  published_at: [DpabStoreConnectionPublished_at]
}

type DpabStoreConnectionId {
  key: ID
  connection: DpabStoreConnection
}

type DpabStoreConnectionCreated_at {
  key: DateTime
  connection: DpabStoreConnection
}

type DpabStoreConnectionUpdated_at {
  key: DateTime
  connection: DpabStoreConnection
}

type DpabStoreConnectionTitle {
  key: String
  connection: DpabStoreConnection
}

type DpabStoreConnectionValue_1 {
  key: String
  connection: DpabStoreConnection
}

type DpabStoreConnectionValue_2 {
  key: String
  connection: DpabStoreConnection
}

type DpabStoreConnectionPublished_at {
  key: DateTime
  connection: DpabStoreConnection
}

input DpabStoreInput {
  title: String
  value_1: String
  value_2: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDpabStoreInput {
  title: String
  value_1: String
  value_2: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDpabStoreInput {
  data: DpabStoreInput
}

type createDpabStorePayload {
  dpabStore: DpabStore
}

input updateDpabStoreInput {
  where: InputID
  data: editDpabStoreInput
}

type updateDpabStorePayload {
  dpabStore: DpabStore
}

input deleteDpabStoreInput {
  where: InputID
}

type deleteDpabStorePayload {
  dpabStore: DpabStore
}

type FavoriteProduct {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  users_permissions_user: UsersPermissionsUser
  product: Products
  published_at: DateTime
}

type FavoriteProductConnection {
  values: [FavoriteProduct]
  groupBy: FavoriteProductGroupBy
  aggregate: FavoriteProductAggregator
}

type FavoriteProductAggregator {
  count: Int
  totalCount: Int
}

type FavoriteProductGroupBy {
  id: [FavoriteProductConnectionId]
  created_at: [FavoriteProductConnectionCreated_at]
  updated_at: [FavoriteProductConnectionUpdated_at]
  users_permissions_user: [FavoriteProductConnectionUsers_permissions_user]
  product: [FavoriteProductConnectionProduct]
  published_at: [FavoriteProductConnectionPublished_at]
}

type FavoriteProductConnectionId {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionCreated_at {
  key: DateTime
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionUpdated_at {
  key: DateTime
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionUsers_permissions_user {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionProduct {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionPublished_at {
  key: DateTime
  connection: FavoriteProductConnection
}

input FavoriteProductInput {
  users_permissions_user: ID
  product: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editFavoriteProductInput {
  users_permissions_user: ID
  product: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createFavoriteProductInput {
  data: FavoriteProductInput
}

type createFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

input updateFavoriteProductInput {
  where: InputID
  data: editFavoriteProductInput
}

type updateFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

input deleteFavoriteProductInput {
  where: InputID
}

type deleteFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

type FourIcons {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  text: String
  svg: String
  published_at: DateTime
}

type FourIconsConnection {
  values: [FourIcons]
  groupBy: FourIconsGroupBy
  aggregate: FourIconsAggregator
}

type FourIconsAggregator {
  count: Int
  totalCount: Int
}

type FourIconsGroupBy {
  id: [FourIconsConnectionId]
  created_at: [FourIconsConnectionCreated_at]
  updated_at: [FourIconsConnectionUpdated_at]
  header: [FourIconsConnectionHeader]
  text: [FourIconsConnectionText]
  svg: [FourIconsConnectionSvg]
  published_at: [FourIconsConnectionPublished_at]
}

type FourIconsConnectionId {
  key: ID
  connection: FourIconsConnection
}

type FourIconsConnectionCreated_at {
  key: DateTime
  connection: FourIconsConnection
}

type FourIconsConnectionUpdated_at {
  key: DateTime
  connection: FourIconsConnection
}

type FourIconsConnectionHeader {
  key: String
  connection: FourIconsConnection
}

type FourIconsConnectionText {
  key: String
  connection: FourIconsConnection
}

type FourIconsConnectionSvg {
  key: String
  connection: FourIconsConnection
}

type FourIconsConnectionPublished_at {
  key: DateTime
  connection: FourIconsConnection
}

input FourIconInput {
  header: String
  text: String
  svg: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editFourIconInput {
  header: String
  text: String
  svg: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createFourIconInput {
  data: FourIconInput
}

type createFourIconPayload {
  fourIcon: FourIcons
}

input updateFourIconInput {
  where: InputID
  data: editFourIconInput
}

type updateFourIconPayload {
  fourIcon: FourIcons
}

input deleteFourIconInput {
  where: InputID
}

type deleteFourIconPayload {
  fourIcon: FourIcons
}

enum ENUM_GIFTWRAP_SECURE {
  One
}

type GiftWrap {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  price: Long
  Name: String
  Text: String
  secure: ENUM_GIFTWRAP_SECURE!
  published_at: DateTime
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type GiftWrapConnection {
  values: [GiftWrap]
  groupBy: GiftWrapGroupBy
  aggregate: GiftWrapAggregator
}

type GiftWrapAggregator {
  count: Int
  totalCount: Int
}

type GiftWrapGroupBy {
  id: [GiftWrapConnectionId]
  created_at: [GiftWrapConnectionCreated_at]
  updated_at: [GiftWrapConnectionUpdated_at]
  price: [GiftWrapConnectionPrice]
  Name: [GiftWrapConnectionName]
  Text: [GiftWrapConnectionText]
  secure: [GiftWrapConnectionSecure]
  published_at: [GiftWrapConnectionPublished_at]
}

type GiftWrapConnectionId {
  key: ID
  connection: GiftWrapConnection
}

type GiftWrapConnectionCreated_at {
  key: DateTime
  connection: GiftWrapConnection
}

type GiftWrapConnectionUpdated_at {
  key: DateTime
  connection: GiftWrapConnection
}

type GiftWrapConnectionPrice {
  key: ID
  connection: GiftWrapConnection
}

type GiftWrapConnectionName {
  key: String
  connection: GiftWrapConnection
}

type GiftWrapConnectionText {
  key: String
  connection: GiftWrapConnection
}

type GiftWrapConnectionSecure {
  key: String
  connection: GiftWrapConnection
}

type GiftWrapConnectionPublished_at {
  key: DateTime
  connection: GiftWrapConnection
}

input GiftWrapInput {
  images: [ID]
  price: Long
  Name: String
  Text: String
  secure: ENUM_GIFTWRAP_SECURE
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editGiftWrapInput {
  images: [ID]
  price: Long
  Name: String
  Text: String
  secure: ENUM_GIFTWRAP_SECURE
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createGiftWrapInput {
  data: GiftWrapInput
}

type createGiftWrapPayload {
  giftWrap: GiftWrap
}

input updateGiftWrapInput {
  where: InputID
  data: editGiftWrapInput
}

type updateGiftWrapPayload {
  giftWrap: GiftWrap
}

input deleteGiftWrapInput {
  where: InputID
}

type deleteGiftWrapPayload {
  giftWrap: GiftWrap
}

enum ENUM_INSPIRATION_POSITION {
  HomePageOne
  HomePageTwo
  HomePageThre
  HerrenPageOne
  HerrenPageTwo
  HerrenPageThre
}

type Inspiration {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  text: String
  button_text: String
  url: String
  images: UploadFile
  image_header: String
  image_title: String
  position: ENUM_INSPIRATION_POSITION!
  published_at: DateTime
}

type InspirationConnection {
  values: [Inspiration]
  groupBy: InspirationGroupBy
  aggregate: InspirationAggregator
}

type InspirationAggregator {
  count: Int
  totalCount: Int
}

type InspirationGroupBy {
  id: [InspirationConnectionId]
  created_at: [InspirationConnectionCreated_at]
  updated_at: [InspirationConnectionUpdated_at]
  header: [InspirationConnectionHeader]
  title: [InspirationConnectionTitle]
  text: [InspirationConnectionText]
  button_text: [InspirationConnectionButton_text]
  url: [InspirationConnectionUrl]
  images: [InspirationConnectionImages]
  image_header: [InspirationConnectionImage_header]
  image_title: [InspirationConnectionImage_title]
  position: [InspirationConnectionPosition]
  published_at: [InspirationConnectionPublished_at]
}

type InspirationConnectionId {
  key: ID
  connection: InspirationConnection
}

type InspirationConnectionCreated_at {
  key: DateTime
  connection: InspirationConnection
}

type InspirationConnectionUpdated_at {
  key: DateTime
  connection: InspirationConnection
}

type InspirationConnectionHeader {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionTitle {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionText {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionButton_text {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionUrl {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionImages {
  key: ID
  connection: InspirationConnection
}

type InspirationConnectionImage_header {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionImage_title {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionPosition {
  key: String
  connection: InspirationConnection
}

type InspirationConnectionPublished_at {
  key: DateTime
  connection: InspirationConnection
}

input InspirationInput {
  header: String
  title: String
  text: String
  button_text: String
  url: String
  images: ID
  image_header: String
  image_title: String
  position: ENUM_INSPIRATION_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editInspirationInput {
  header: String
  title: String
  text: String
  button_text: String
  url: String
  images: ID
  image_header: String
  image_title: String
  position: ENUM_INSPIRATION_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createInspirationInput {
  data: InspirationInput
}

type createInspirationPayload {
  inspiration: Inspiration
}

input updateInspirationInput {
  where: InputID
  data: editInspirationInput
}

type updateInspirationPayload {
  inspiration: Inspiration
}

input deleteInspirationInput {
  where: InputID
}

type deleteInspirationPayload {
  inspiration: Inspiration
}

enum ENUM_MAGAZINPRESENTATION_POSITION {
  right
  left
  center
  full
}

type MagazinPresentation {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  images_1: UploadFile
  text_1: String
  text_2: String
  images_2: UploadFile
  position: ENUM_MAGAZINPRESENTATION_POSITION
  published_at: DateTime
  products(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type MagazinPresentationConnection {
  values: [MagazinPresentation]
  groupBy: MagazinPresentationGroupBy
  aggregate: MagazinPresentationAggregator
}

type MagazinPresentationAggregator {
  count: Int
  totalCount: Int
}

type MagazinPresentationGroupBy {
  id: [MagazinPresentationConnectionId]
  created_at: [MagazinPresentationConnectionCreated_at]
  updated_at: [MagazinPresentationConnectionUpdated_at]
  images_1: [MagazinPresentationConnectionImages_1]
  text_1: [MagazinPresentationConnectionText_1]
  text_2: [MagazinPresentationConnectionText_2]
  images_2: [MagazinPresentationConnectionImages_2]
  position: [MagazinPresentationConnectionPosition]
  published_at: [MagazinPresentationConnectionPublished_at]
}

type MagazinPresentationConnectionId {
  key: ID
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionCreated_at {
  key: DateTime
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionUpdated_at {
  key: DateTime
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionImages_1 {
  key: ID
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionText_1 {
  key: String
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionText_2 {
  key: String
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionImages_2 {
  key: ID
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionPosition {
  key: String
  connection: MagazinPresentationConnection
}

type MagazinPresentationConnectionPublished_at {
  key: DateTime
  connection: MagazinPresentationConnection
}

input MagazinPresentationInput {
  images_1: ID
  text_1: String
  text_2: String
  images_2: ID
  position: ENUM_MAGAZINPRESENTATION_POSITION
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMagazinPresentationInput {
  images_1: ID
  text_1: String
  text_2: String
  images_2: ID
  position: ENUM_MAGAZINPRESENTATION_POSITION
  products: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMagazinPresentationInput {
  data: MagazinPresentationInput
}

type createMagazinPresentationPayload {
  magazinPresentation: MagazinPresentation
}

input updateMagazinPresentationInput {
  where: InputID
  data: editMagazinPresentationInput
}

type updateMagazinPresentationPayload {
  magazinPresentation: MagazinPresentation
}

input deleteMagazinPresentationInput {
  where: InputID
}

type deleteMagazinPresentationPayload {
  magazinPresentation: MagazinPresentation
}

type MainAccount {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  addresses: String
  user_data: String
  orders: String
  wishlist: String
  newsletter: String
  my_bookmarks: String
  published_at: DateTime
}

type MainAccountConnection {
  values: [MainAccount]
  groupBy: MainAccountGroupBy
  aggregate: MainAccountAggregator
}

type MainAccountAggregator {
  count: Int
  totalCount: Int
}

type MainAccountGroupBy {
  id: [MainAccountConnectionId]
  created_at: [MainAccountConnectionCreated_at]
  updated_at: [MainAccountConnectionUpdated_at]
  addresses: [MainAccountConnectionAddresses]
  user_data: [MainAccountConnectionUser_data]
  orders: [MainAccountConnectionOrders]
  wishlist: [MainAccountConnectionWishlist]
  newsletter: [MainAccountConnectionNewsletter]
  my_bookmarks: [MainAccountConnectionMy_bookmarks]
  published_at: [MainAccountConnectionPublished_at]
}

type MainAccountConnectionId {
  key: ID
  connection: MainAccountConnection
}

type MainAccountConnectionCreated_at {
  key: DateTime
  connection: MainAccountConnection
}

type MainAccountConnectionUpdated_at {
  key: DateTime
  connection: MainAccountConnection
}

type MainAccountConnectionAddresses {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionUser_data {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionOrders {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionWishlist {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionNewsletter {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionMy_bookmarks {
  key: String
  connection: MainAccountConnection
}

type MainAccountConnectionPublished_at {
  key: DateTime
  connection: MainAccountConnection
}

input MainAccountInput {
  addresses: String
  user_data: String
  orders: String
  wishlist: String
  newsletter: String
  my_bookmarks: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMainAccountInput {
  addresses: String
  user_data: String
  orders: String
  wishlist: String
  newsletter: String
  my_bookmarks: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMainAccountInput {
  data: MainAccountInput
}

type createMainAccountPayload {
  mainAccount: MainAccount
}

input updateMainAccountInput {
  where: InputID
  data: editMainAccountInput
}

type updateMainAccountPayload {
  mainAccount: MainAccount
}

input deleteMainAccountInput {
  where: InputID
}

type deleteMainAccountPayload {
  mainAccount: MainAccount
}

type MeinKonto {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  published_at: DateTime
}

type MeinKontoConnection {
  values: [MeinKonto]
  groupBy: MeinKontoGroupBy
  aggregate: MeinKontoAggregator
}

type MeinKontoAggregator {
  count: Int
  totalCount: Int
}

type MeinKontoGroupBy {
  id: [MeinKontoConnectionId]
  created_at: [MeinKontoConnectionCreated_at]
  updated_at: [MeinKontoConnectionUpdated_at]
  title: [MeinKontoConnectionTitle]
  published_at: [MeinKontoConnectionPublished_at]
}

type MeinKontoConnectionId {
  key: ID
  connection: MeinKontoConnection
}

type MeinKontoConnectionCreated_at {
  key: DateTime
  connection: MeinKontoConnection
}

type MeinKontoConnectionUpdated_at {
  key: DateTime
  connection: MeinKontoConnection
}

type MeinKontoConnectionTitle {
  key: String
  connection: MeinKontoConnection
}

type MeinKontoConnectionPublished_at {
  key: DateTime
  connection: MeinKontoConnection
}

input MeinKontoInput {
  title: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMeinKontoInput {
  title: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMeinKontoInput {
  data: MeinKontoInput
}

type createMeinKontoPayload {
  meinKonto: MeinKonto
}

input updateMeinKontoInput {
  where: InputID
  data: editMeinKontoInput
}

type updateMeinKontoPayload {
  meinKonto: MeinKonto
}

input deleteMeinKontoInput {
  where: InputID
}

type deleteMeinKontoPayload {
  meinKonto: MeinKonto
}

enum ENUM_MENUITEM_POSITION {
  A
  B
  C
  D
  E
  F
  G
  H
  I
  J
  K
  L
  M
  N
  O
  P
  Q
}

type MenuItem {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  item_name: String
  title: String
  images: UploadFile
  url: String
  position: ENUM_MENUITEM_POSITION!
  published_at: DateTime
  categories(sort: String, limit: Int, start: Int, where: JSON): [Category]
}

type MenuItemConnection {
  values: [MenuItem]
  groupBy: MenuItemGroupBy
  aggregate: MenuItemAggregator
}

type MenuItemAggregator {
  count: Int
  totalCount: Int
}

type MenuItemGroupBy {
  id: [MenuItemConnectionId]
  created_at: [MenuItemConnectionCreated_at]
  updated_at: [MenuItemConnectionUpdated_at]
  item_name: [MenuItemConnectionItem_name]
  title: [MenuItemConnectionTitle]
  images: [MenuItemConnectionImages]
  url: [MenuItemConnectionUrl]
  position: [MenuItemConnectionPosition]
  published_at: [MenuItemConnectionPublished_at]
}

type MenuItemConnectionId {
  key: ID
  connection: MenuItemConnection
}

type MenuItemConnectionCreated_at {
  key: DateTime
  connection: MenuItemConnection
}

type MenuItemConnectionUpdated_at {
  key: DateTime
  connection: MenuItemConnection
}

type MenuItemConnectionItem_name {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionTitle {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionImages {
  key: ID
  connection: MenuItemConnection
}

type MenuItemConnectionUrl {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionPosition {
  key: String
  connection: MenuItemConnection
}

type MenuItemConnectionPublished_at {
  key: DateTime
  connection: MenuItemConnection
}

input MenuItemInput {
  item_name: String
  categories: [ID]
  title: String
  images: ID
  url: String
  position: ENUM_MENUITEM_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editMenuItemInput {
  item_name: String
  categories: [ID]
  title: String
  images: ID
  url: String
  position: ENUM_MENUITEM_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createMenuItemInput {
  data: MenuItemInput
}

type createMenuItemPayload {
  menuItem: MenuItem
}

input updateMenuItemInput {
  where: InputID
  data: editMenuItemInput
}

type updateMenuItemPayload {
  menuItem: MenuItem
}

input deleteMenuItemInput {
  where: InputID
}

type deleteMenuItemPayload {
  menuItem: MenuItem
}

type NewProductLimit {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  new_product_limit: Long
  published_at: DateTime
}

input NewProductLimitInput {
  new_product_limit: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNewProductLimitInput {
  new_product_limit: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateNewProductLimitInput {
  data: editNewProductLimitInput
}

type updateNewProductLimitPayload {
  newProductLimit: NewProductLimit
}

type deleteNewProductLimitPayload {
  newProductLimit: NewProductLimit
}

enum ENUM_NEWSREPORT_POSITION {
  HomePageOne
  HomePageTwo
  HomePageThree
  HomePageFive
  HomePageSix
  HerrenPageOne
  HerrenPageTwo
  ShopPageOne
  ShopPageTwo
  ShopPageThree
  MagazinPageOne
  MagazinPageTwo
}

type NewsReport {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  text: String
  url: String
  link_text: String
  images: UploadFile
  position: ENUM_NEWSREPORT_POSITION!
  published_at: DateTime
}

type NewsReportConnection {
  values: [NewsReport]
  groupBy: NewsReportGroupBy
  aggregate: NewsReportAggregator
}

type NewsReportAggregator {
  count: Int
  totalCount: Int
}

type NewsReportGroupBy {
  id: [NewsReportConnectionId]
  created_at: [NewsReportConnectionCreated_at]
  updated_at: [NewsReportConnectionUpdated_at]
  header: [NewsReportConnectionHeader]
  title: [NewsReportConnectionTitle]
  text: [NewsReportConnectionText]
  url: [NewsReportConnectionUrl]
  link_text: [NewsReportConnectionLink_text]
  images: [NewsReportConnectionImages]
  position: [NewsReportConnectionPosition]
  published_at: [NewsReportConnectionPublished_at]
}

type NewsReportConnectionId {
  key: ID
  connection: NewsReportConnection
}

type NewsReportConnectionCreated_at {
  key: DateTime
  connection: NewsReportConnection
}

type NewsReportConnectionUpdated_at {
  key: DateTime
  connection: NewsReportConnection
}

type NewsReportConnectionHeader {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionTitle {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionText {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionUrl {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionLink_text {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionImages {
  key: ID
  connection: NewsReportConnection
}

type NewsReportConnectionPosition {
  key: String
  connection: NewsReportConnection
}

type NewsReportConnectionPublished_at {
  key: DateTime
  connection: NewsReportConnection
}

input NewsReportInput {
  header: String
  title: String
  text: String
  url: String
  link_text: String
  images: ID
  position: ENUM_NEWSREPORT_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNewsReportInput {
  header: String
  title: String
  text: String
  url: String
  link_text: String
  images: ID
  position: ENUM_NEWSREPORT_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createNewsReportInput {
  data: NewsReportInput
}

type createNewsReportPayload {
  newsReport: NewsReport
}

input updateNewsReportInput {
  where: InputID
  data: editNewsReportInput
}

type updateNewsReportPayload {
  newsReport: NewsReport
}

input deleteNewsReportInput {
  where: InputID
}

type deleteNewsReportPayload {
  newsReport: NewsReport
}

type Newsletter {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Subject: String
  HTML_describe: String
  published_at: DateTime
}

type NewsletterConnection {
  values: [Newsletter]
  groupBy: NewsletterGroupBy
  aggregate: NewsletterAggregator
}

type NewsletterAggregator {
  count: Int
  totalCount: Int
}

type NewsletterGroupBy {
  id: [NewsletterConnectionId]
  created_at: [NewsletterConnectionCreated_at]
  updated_at: [NewsletterConnectionUpdated_at]
  Subject: [NewsletterConnectionSubject]
  HTML_describe: [NewsletterConnectionHTML_describe]
  published_at: [NewsletterConnectionPublished_at]
}

type NewsletterConnectionId {
  key: ID
  connection: NewsletterConnection
}

type NewsletterConnectionCreated_at {
  key: DateTime
  connection: NewsletterConnection
}

type NewsletterConnectionUpdated_at {
  key: DateTime
  connection: NewsletterConnection
}

type NewsletterConnectionSubject {
  key: String
  connection: NewsletterConnection
}

type NewsletterConnectionHTML_describe {
  key: String
  connection: NewsletterConnection
}

type NewsletterConnectionPublished_at {
  key: DateTime
  connection: NewsletterConnection
}

input NewsletterInput {
  Subject: String
  HTML_describe: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNewsletterInput {
  Subject: String
  HTML_describe: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createNewsletterInput {
  data: NewsletterInput
}

type createNewsletterPayload {
  newsletter: Newsletter
}

input updateNewsletterInput {
  where: InputID
  data: editNewsletterInput
}

type updateNewsletterPayload {
  newsletter: Newsletter
}

input deleteNewsletterInput {
  where: InputID
}

type deleteNewsletterPayload {
  newsletter: Newsletter
}

enum ENUM_PAGEHEADER_POSITION {
  grey
  black
}

type PageHeader {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  describe_HTML_CSS: String
  position: ENUM_PAGEHEADER_POSITION
  published_at: DateTime
}

type PageHeaderConnection {
  values: [PageHeader]
  groupBy: PageHeaderGroupBy
  aggregate: PageHeaderAggregator
}

type PageHeaderAggregator {
  count: Int
  totalCount: Int
}

type PageHeaderGroupBy {
  id: [PageHeaderConnectionId]
  created_at: [PageHeaderConnectionCreated_at]
  updated_at: [PageHeaderConnectionUpdated_at]
  describe_HTML_CSS: [PageHeaderConnectionDescribe_HTML_CSS]
  position: [PageHeaderConnectionPosition]
  published_at: [PageHeaderConnectionPublished_at]
}

type PageHeaderConnectionId {
  key: ID
  connection: PageHeaderConnection
}

type PageHeaderConnectionCreated_at {
  key: DateTime
  connection: PageHeaderConnection
}

type PageHeaderConnectionUpdated_at {
  key: DateTime
  connection: PageHeaderConnection
}

type PageHeaderConnectionDescribe_HTML_CSS {
  key: String
  connection: PageHeaderConnection
}

type PageHeaderConnectionPosition {
  key: String
  connection: PageHeaderConnection
}

type PageHeaderConnectionPublished_at {
  key: DateTime
  connection: PageHeaderConnection
}

input PageHeaderInput {
  describe_HTML_CSS: String
  position: ENUM_PAGEHEADER_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPageHeaderInput {
  describe_HTML_CSS: String
  position: ENUM_PAGEHEADER_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPageHeaderInput {
  data: PageHeaderInput
}

type createPageHeaderPayload {
  pageHeader: PageHeader
}

input updatePageHeaderInput {
  where: InputID
  data: editPageHeaderInput
}

type updatePageHeaderPayload {
  pageHeader: PageHeader
}

input deletePageHeaderInput {
  where: InputID
}

type deletePageHeaderPayload {
  pageHeader: PageHeader
}

type PermanentDiscount {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  value: Long
  discount: Long
  published_at: DateTime
}

input PermanentDiscountInput {
  value: Long
  discount: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPermanentDiscountInput {
  value: Long
  discount: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updatePermanentDiscountInput {
  data: editPermanentDiscountInput
}

type updatePermanentDiscountPayload {
  permanentDiscount: PermanentDiscount
}

type deletePermanentDiscountPayload {
  permanentDiscount: PermanentDiscount
}

enum ENUM_PRODUCTWITHLEFTTEXT_POSITION {
  HomePageOne
  HomePageTwo
}

type ProductWithLeftText {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Header: String
  Title: String
  Text: String
  Button_text: String
  url: String
  position: ENUM_PRODUCTWITHLEFTTEXT_POSITION!
  published_at: DateTime
}

type ProductWithLeftTextConnection {
  values: [ProductWithLeftText]
  groupBy: ProductWithLeftTextGroupBy
  aggregate: ProductWithLeftTextAggregator
}

type ProductWithLeftTextAggregator {
  count: Int
  totalCount: Int
}

type ProductWithLeftTextGroupBy {
  id: [ProductWithLeftTextConnectionId]
  created_at: [ProductWithLeftTextConnectionCreated_at]
  updated_at: [ProductWithLeftTextConnectionUpdated_at]
  Header: [ProductWithLeftTextConnectionHeader]
  Title: [ProductWithLeftTextConnectionTitle]
  Text: [ProductWithLeftTextConnectionText]
  Button_text: [ProductWithLeftTextConnectionButton_text]
  url: [ProductWithLeftTextConnectionUrl]
  position: [ProductWithLeftTextConnectionPosition]
  published_at: [ProductWithLeftTextConnectionPublished_at]
}

type ProductWithLeftTextConnectionId {
  key: ID
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionCreated_at {
  key: DateTime
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionUpdated_at {
  key: DateTime
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionHeader {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionTitle {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionText {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionButton_text {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionUrl {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionPosition {
  key: String
  connection: ProductWithLeftTextConnection
}

type ProductWithLeftTextConnectionPublished_at {
  key: DateTime
  connection: ProductWithLeftTextConnection
}

input ProductWithLeftTextInput {
  Header: String
  Title: String
  Text: String
  Button_text: String
  url: String
  position: ENUM_PRODUCTWITHLEFTTEXT_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductWithLeftTextInput {
  Header: String
  Title: String
  Text: String
  Button_text: String
  url: String
  position: ENUM_PRODUCTWITHLEFTTEXT_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductWithLeftTextInput {
  data: ProductWithLeftTextInput
}

type createProductWithLeftTextPayload {
  productWithLeftText: ProductWithLeftText
}

input updateProductWithLeftTextInput {
  where: InputID
  data: editProductWithLeftTextInput
}

type updateProductWithLeftTextPayload {
  productWithLeftText: ProductWithLeftText
}

input deleteProductWithLeftTextInput {
  where: InputID
}

type deleteProductWithLeftTextPayload {
  productWithLeftText: ProductWithLeftText
}

type Products {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  price: String
  clean_product: Boolean
  brand: String
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: TypeTest
  category: Category
  sub_category: SubCategory
  menu_item: MenuItem
  name: String
  magazin_presentation: MagazinPresentation
  kind: String
  New_Date_Limit: Date
  video: UploadFile
  published_at: DateTime
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type ProductsConnection {
  values: [Products]
  groupBy: ProductsGroupBy
  aggregate: ProductsAggregator
}

type ProductsAggregator {
  count: Int
  totalCount: Int
}

type ProductsGroupBy {
  id: [ProductsConnectionId]
  created_at: [ProductsConnectionCreated_at]
  updated_at: [ProductsConnectionUpdated_at]
  price: [ProductsConnectionPrice]
  clean_product: [ProductsConnectionClean_product]
  brand: [ProductsConnectionBrand]
  for_sale_count: [ProductsConnectionFor_sale_count]
  unit: [ProductsConnectionUnit]
  discount: [ProductsConnectionDiscount]
  type_test: [ProductsConnectionType_test]
  category: [ProductsConnectionCategory]
  sub_category: [ProductsConnectionSub_category]
  menu_item: [ProductsConnectionMenu_item]
  name: [ProductsConnectionName]
  magazin_presentation: [ProductsConnectionMagazin_presentation]
  kind: [ProductsConnectionKind]
  New_Date_Limit: [ProductsConnectionNew_Date_Limit]
  video: [ProductsConnectionVideo]
  published_at: [ProductsConnectionPublished_at]
}

type ProductsConnectionId {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionCreated_at {
  key: DateTime
  connection: ProductsConnection
}

type ProductsConnectionUpdated_at {
  key: DateTime
  connection: ProductsConnection
}

type ProductsConnectionPrice {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionClean_product {
  key: Boolean
  connection: ProductsConnection
}

type ProductsConnectionBrand {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionFor_sale_count {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionUnit {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionDiscount {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionType_test {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionCategory {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionSub_category {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionMenu_item {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionName {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionMagazin_presentation {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionKind {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionNew_Date_Limit {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionVideo {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionPublished_at {
  key: DateTime
  connection: ProductsConnection
}

input ProductInput {
  price: String
  images: [ID]
  clean_product: Boolean
  brand: String
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: ID
  category: ID
  sub_category: ID
  menu_item: ID
  name: String
  magazin_presentation: ID
  kind: String
  New_Date_Limit: Date
  video: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductInput {
  price: String
  images: [ID]
  clean_product: Boolean
  brand: String
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: ID
  category: ID
  sub_category: ID
  menu_item: ID
  name: String
  magazin_presentation: ID
  kind: String
  New_Date_Limit: Date
  video: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductInput {
  data: ProductInput
}

type createProductPayload {
  product: Products
}

input updateProductInput {
  where: InputID
  data: editProductInput
}

type updateProductPayload {
  product: Products
}

input deleteProductInput {
  where: InputID
}

type deleteProductPayload {
  product: Products
}

enum ENUM_SECTIONUNDERNAVBAR_POSITION {
  HomePage
  HerrenPage
}

type SectionUnderNavbar {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  title: String
  button_text: String
  url: String
  images: UploadFile
  position: ENUM_SECTIONUNDERNAVBAR_POSITION!
  published_at: DateTime
}

type SectionUnderNavbarConnection {
  values: [SectionUnderNavbar]
  groupBy: SectionUnderNavbarGroupBy
  aggregate: SectionUnderNavbarAggregator
}

type SectionUnderNavbarAggregator {
  count: Int
  totalCount: Int
}

type SectionUnderNavbarGroupBy {
  id: [SectionUnderNavbarConnectionId]
  created_at: [SectionUnderNavbarConnectionCreated_at]
  updated_at: [SectionUnderNavbarConnectionUpdated_at]
  header: [SectionUnderNavbarConnectionHeader]
  title: [SectionUnderNavbarConnectionTitle]
  button_text: [SectionUnderNavbarConnectionButton_text]
  url: [SectionUnderNavbarConnectionUrl]
  images: [SectionUnderNavbarConnectionImages]
  position: [SectionUnderNavbarConnectionPosition]
  published_at: [SectionUnderNavbarConnectionPublished_at]
}

type SectionUnderNavbarConnectionId {
  key: ID
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionCreated_at {
  key: DateTime
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionUpdated_at {
  key: DateTime
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionHeader {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionTitle {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionButton_text {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionUrl {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionImages {
  key: ID
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionPosition {
  key: String
  connection: SectionUnderNavbarConnection
}

type SectionUnderNavbarConnectionPublished_at {
  key: DateTime
  connection: SectionUnderNavbarConnection
}

input SectionUnderNavbarInput {
  header: String
  title: String
  button_text: String
  url: String
  images: ID
  position: ENUM_SECTIONUNDERNAVBAR_POSITION!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editSectionUnderNavbarInput {
  header: String
  title: String
  button_text: String
  url: String
  images: ID
  position: ENUM_SECTIONUNDERNAVBAR_POSITION
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createSectionUnderNavbarInput {
  data: SectionUnderNavbarInput
}

type createSectionUnderNavbarPayload {
  sectionUnderNavbar: SectionUnderNavbar
}

input updateSectionUnderNavbarInput {
  where: InputID
  data: editSectionUnderNavbarInput
}

type updateSectionUnderNavbarPayload {
  sectionUnderNavbar: SectionUnderNavbar
}

input deleteSectionUnderNavbarInput {
  where: InputID
}

type deleteSectionUnderNavbarPayload {
  sectionUnderNavbar: SectionUnderNavbar
}

type ShopPageLargeText {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header: String
  text: String
  published_at: DateTime
}

type ShopPageLargeTextConnection {
  values: [ShopPageLargeText]
  groupBy: ShopPageLargeTextGroupBy
  aggregate: ShopPageLargeTextAggregator
}

type ShopPageLargeTextAggregator {
  count: Int
  totalCount: Int
}

type ShopPageLargeTextGroupBy {
  id: [ShopPageLargeTextConnectionId]
  created_at: [ShopPageLargeTextConnectionCreated_at]
  updated_at: [ShopPageLargeTextConnectionUpdated_at]
  header: [ShopPageLargeTextConnectionHeader]
  text: [ShopPageLargeTextConnectionText]
  published_at: [ShopPageLargeTextConnectionPublished_at]
}

type ShopPageLargeTextConnectionId {
  key: ID
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionCreated_at {
  key: DateTime
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionUpdated_at {
  key: DateTime
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionHeader {
  key: String
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionText {
  key: String
  connection: ShopPageLargeTextConnection
}

type ShopPageLargeTextConnectionPublished_at {
  key: DateTime
  connection: ShopPageLargeTextConnection
}

input ShopPageLargeTextInput {
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShopPageLargeTextInput {
  header: String
  text: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShopPageLargeTextInput {
  data: ShopPageLargeTextInput
}

type createShopPageLargeTextPayload {
  shopPageLargeText: ShopPageLargeText
}

input updateShopPageLargeTextInput {
  where: InputID
  data: editShopPageLargeTextInput
}

type updateShopPageLargeTextPayload {
  shopPageLargeText: ShopPageLargeText
}

input deleteShopPageLargeTextInput {
  where: InputID
}

type deleteShopPageLargeTextPayload {
  shopPageLargeText: ShopPageLargeText
}

type ShoppingBasketRecommendation {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  to: String
  from: String
  current_shopping_basket_product_id: JSON
  published_at: DateTime
}

type ShoppingBasketRecommendationConnection {
  values: [ShoppingBasketRecommendation]
  groupBy: ShoppingBasketRecommendationGroupBy
  aggregate: ShoppingBasketRecommendationAggregator
}

type ShoppingBasketRecommendationAggregator {
  count: Int
  totalCount: Int
}

type ShoppingBasketRecommendationGroupBy {
  id: [ShoppingBasketRecommendationConnectionId]
  created_at: [ShoppingBasketRecommendationConnectionCreated_at]
  updated_at: [ShoppingBasketRecommendationConnectionUpdated_at]
  to: [ShoppingBasketRecommendationConnectionTo]
  from: [ShoppingBasketRecommendationConnectionFrom]
  current_shopping_basket_product_id: [ShoppingBasketRecommendationConnectionCurrent_shopping_basket_product_id]
  published_at: [ShoppingBasketRecommendationConnectionPublished_at]
}

type ShoppingBasketRecommendationConnectionId {
  key: ID
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionCreated_at {
  key: DateTime
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionUpdated_at {
  key: DateTime
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionTo {
  key: String
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionFrom {
  key: String
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionCurrent_shopping_basket_product_id {
  key: JSON
  connection: ShoppingBasketRecommendationConnection
}

type ShoppingBasketRecommendationConnectionPublished_at {
  key: DateTime
  connection: ShoppingBasketRecommendationConnection
}

input ShoppingBasketRecommendationInput {
  to: String
  from: String
  current_shopping_basket_product_id: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShoppingBasketRecommendationInput {
  to: String
  from: String
  current_shopping_basket_product_id: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShoppingBasketRecommendationInput {
  data: ShoppingBasketRecommendationInput
}

type createShoppingBasketRecommendationPayload {
  shoppingBasketRecommendation: ShoppingBasketRecommendation
}

input updateShoppingBasketRecommendationInput {
  where: InputID
  data: editShoppingBasketRecommendationInput
}

type updateShoppingBasketRecommendationPayload {
  shoppingBasketRecommendation: ShoppingBasketRecommendation
}

input deleteShoppingBasketRecommendationInput {
  where: InputID
}

type deleteShoppingBasketRecommendationPayload {
  shoppingBasketRecommendation: ShoppingBasketRecommendation
}

type ShoppingBasket {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  users_permissions_user: UsersPermissionsUser
  product: Products
  quantity: Long
  gift_wrap: GiftWrap
  type_test: TypeTest
  published_at: DateTime
}

type ShoppingBasketConnection {
  values: [ShoppingBasket]
  groupBy: ShoppingBasketGroupBy
  aggregate: ShoppingBasketAggregator
}

type ShoppingBasketAggregator {
  count: Int
  totalCount: Int
}

type ShoppingBasketGroupBy {
  id: [ShoppingBasketConnectionId]
  created_at: [ShoppingBasketConnectionCreated_at]
  updated_at: [ShoppingBasketConnectionUpdated_at]
  users_permissions_user: [ShoppingBasketConnectionUsers_permissions_user]
  product: [ShoppingBasketConnectionProduct]
  quantity: [ShoppingBasketConnectionQuantity]
  gift_wrap: [ShoppingBasketConnectionGift_wrap]
  type_test: [ShoppingBasketConnectionType_test]
  published_at: [ShoppingBasketConnectionPublished_at]
}

type ShoppingBasketConnectionId {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionCreated_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionUpdated_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionUsers_permissions_user {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionProduct {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionQuantity {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionGift_wrap {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionType_test {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionPublished_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

input ShoppingBasketInput {
  users_permissions_user: ID
  product: ID
  quantity: Long
  gift_wrap: ID
  type_test: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShoppingBasketInput {
  users_permissions_user: ID
  product: ID
  quantity: Long
  gift_wrap: ID
  type_test: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShoppingBasketInput {
  data: ShoppingBasketInput
}

type createShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

input updateShoppingBasketInput {
  where: InputID
  data: editShoppingBasketInput
}

type updateShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

input deleteShoppingBasketInput {
  where: InputID
}

type deleteShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

enum ENUM_STAIRSECTION_POSITION {
  One
  Two
}

type StairSection {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  header_1: String
  text_1: String
  images_1: UploadFile
  position: ENUM_STAIRSECTION_POSITION!
  header_2: String
  text_2: String
  header_3: String
  text_3: String
  published_at: DateTime
  images_2(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  images_3(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type StairSectionConnection {
  values: [StairSection]
  groupBy: StairSectionGroupBy
  aggregate: StairSectionAggregator
}

type StairSectionAggregator {
  count: Int
  totalCount: Int
}

type StairSectionGroupBy {
  id: [StairSectionConnectionId]
  created_at: [StairSectionConnectionCreated_at]
  updated_at: [StairSectionConnectionUpdated_at]
  header_1: [StairSectionConnectionHeader_1]
  text_1: [StairSectionConnectionText_1]
  images_1: [StairSectionConnectionImages_1]
  position: [StairSectionConnectionPosition]
  header_2: [StairSectionConnectionHeader_2]
  text_2: [StairSectionConnectionText_2]
  header_3: [StairSectionConnectionHeader_3]
  text_3: [StairSectionConnectionText_3]
  published_at: [StairSectionConnectionPublished_at]
}

type StairSectionConnectionId {
  key: ID
  connection: StairSectionConnection
}

type StairSectionConnectionCreated_at {
  key: DateTime
  connection: StairSectionConnection
}

type StairSectionConnectionUpdated_at {
  key: DateTime
  connection: StairSectionConnection
}

type StairSectionConnectionHeader_1 {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionText_1 {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionImages_1 {
  key: ID
  connection: StairSectionConnection
}

type StairSectionConnectionPosition {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionHeader_2 {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionText_2 {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionHeader_3 {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionText_3 {
  key: String
  connection: StairSectionConnection
}

type StairSectionConnectionPublished_at {
  key: DateTime
  connection: StairSectionConnection
}

input StairSectionInput {
  header_1: String
  text_1: String
  images_1: ID
  position: ENUM_STAIRSECTION_POSITION
  header_2: String
  text_2: String
  images_2: [ID]
  header_3: String
  text_3: String
  images_3: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editStairSectionInput {
  header_1: String
  text_1: String
  images_1: ID
  position: ENUM_STAIRSECTION_POSITION
  header_2: String
  text_2: String
  images_2: [ID]
  header_3: String
  text_3: String
  images_3: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createStairSectionInput {
  data: StairSectionInput
}

type createStairSectionPayload {
  stairSection: StairSection
}

input updateStairSectionInput {
  where: InputID
  data: editStairSectionInput
}

type updateStairSectionPayload {
  stairSection: StairSection
}

input deleteStairSectionInput {
  where: InputID
}

type deleteStairSectionPayload {
  stairSection: StairSection
}

type SubCategory {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  SubCategoryName: String!
  published_at: DateTime
}

type SubCategoryConnection {
  values: [SubCategory]
  groupBy: SubCategoryGroupBy
  aggregate: SubCategoryAggregator
}

type SubCategoryAggregator {
  count: Int
  totalCount: Int
}

type SubCategoryGroupBy {
  id: [SubCategoryConnectionId]
  created_at: [SubCategoryConnectionCreated_at]
  updated_at: [SubCategoryConnectionUpdated_at]
  SubCategoryName: [SubCategoryConnectionSubCategoryName]
  published_at: [SubCategoryConnectionPublished_at]
}

type SubCategoryConnectionId {
  key: ID
  connection: SubCategoryConnection
}

type SubCategoryConnectionCreated_at {
  key: DateTime
  connection: SubCategoryConnection
}

type SubCategoryConnectionUpdated_at {
  key: DateTime
  connection: SubCategoryConnection
}

type SubCategoryConnectionSubCategoryName {
  key: String
  connection: SubCategoryConnection
}

type SubCategoryConnectionPublished_at {
  key: DateTime
  connection: SubCategoryConnection
}

input SubCategoryInput {
  SubCategoryName: String!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editSubCategoryInput {
  SubCategoryName: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createSubCategoryInput {
  data: SubCategoryInput
}

type createSubCategoryPayload {
  subCategory: SubCategory
}

input updateSubCategoryInput {
  where: InputID
  data: editSubCategoryInput
}

type updateSubCategoryPayload {
  subCategory: SubCategory
}

input deleteSubCategoryInput {
  where: InputID
}

type deleteSubCategoryPayload {
  subCategory: SubCategory
}

type TypeTest {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  brand: String
  price: Float
  size: Long
  quantity: Long
  product: Products
  images: UploadFile
  published_at: DateTime
}

type TypeTestConnection {
  values: [TypeTest]
  groupBy: TypeTestGroupBy
  aggregate: TypeTestAggregator
}

type TypeTestAggregator {
  count: Int
  totalCount: Int
  sum: TypeTestAggregatorSum
  avg: TypeTestAggregatorAvg
  min: TypeTestAggregatorMin
  max: TypeTestAggregatorMax
}

type TypeTestAggregatorSum {
  price: Float
}

type TypeTestAggregatorAvg {
  price: Float
}

type TypeTestAggregatorMin {
  price: Float
}

type TypeTestAggregatorMax {
  price: Float
}

type TypeTestGroupBy {
  id: [TypeTestConnectionId]
  created_at: [TypeTestConnectionCreated_at]
  updated_at: [TypeTestConnectionUpdated_at]
  brand: [TypeTestConnectionBrand]
  price: [TypeTestConnectionPrice]
  size: [TypeTestConnectionSize]
  quantity: [TypeTestConnectionQuantity]
  product: [TypeTestConnectionProduct]
  images: [TypeTestConnectionImages]
  published_at: [TypeTestConnectionPublished_at]
}

type TypeTestConnectionId {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionCreated_at {
  key: DateTime
  connection: TypeTestConnection
}

type TypeTestConnectionUpdated_at {
  key: DateTime
  connection: TypeTestConnection
}

type TypeTestConnectionBrand {
  key: String
  connection: TypeTestConnection
}

type TypeTestConnectionPrice {
  key: Float
  connection: TypeTestConnection
}

type TypeTestConnectionSize {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionQuantity {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionProduct {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionImages {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionPublished_at {
  key: DateTime
  connection: TypeTestConnection
}

input TypeTestInput {
  brand: String
  price: Float
  size: Long
  quantity: Long
  product: ID
  images: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editTypeTestInput {
  brand: String
  price: Float
  size: Long
  quantity: Long
  product: ID
  images: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createTypeTestInput {
  data: TypeTestInput
}

type createTypeTestPayload {
  typeTest: TypeTest
}

input updateTypeTestInput {
  where: InputID
  data: editTypeTestInput
}

type updateTypeTestPayload {
  typeTest: TypeTest
}

input deleteTypeTestInput {
  where: InputID
}

type deleteTypeTestPayload {
  typeTest: TypeTest
}

type UserNewsletter {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  First_name: String
  Surname: String
  Gender: String
  Email: String
  published_at: DateTime
}

type UserNewsletterConnection {
  values: [UserNewsletter]
  groupBy: UserNewsletterGroupBy
  aggregate: UserNewsletterAggregator
}

type UserNewsletterAggregator {
  count: Int
  totalCount: Int
}

type UserNewsletterGroupBy {
  id: [UserNewsletterConnectionId]
  created_at: [UserNewsletterConnectionCreated_at]
  updated_at: [UserNewsletterConnectionUpdated_at]
  First_name: [UserNewsletterConnectionFirst_name]
  Surname: [UserNewsletterConnectionSurname]
  Gender: [UserNewsletterConnectionGender]
  Email: [UserNewsletterConnectionEmail]
  published_at: [UserNewsletterConnectionPublished_at]
}

type UserNewsletterConnectionId {
  key: ID
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionCreated_at {
  key: DateTime
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionUpdated_at {
  key: DateTime
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionFirst_name {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionSurname {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionGender {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionEmail {
  key: String
  connection: UserNewsletterConnection
}

type UserNewsletterConnectionPublished_at {
  key: DateTime
  connection: UserNewsletterConnection
}

input UserNewsletterInput {
  First_name: String
  Surname: String
  Gender: String
  Email: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editUserNewsletterInput {
  First_name: String
  Surname: String
  Gender: String
  Email: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createUserNewsletterInput {
  data: UserNewsletterInput
}

type createUserNewsletterPayload {
  userNewsletter: UserNewsletter
}

input updateUserNewsletterInput {
  where: InputID
  data: editUserNewsletterInput
}

type updateUserNewsletterPayload {
  userNewsletter: UserNewsletter
}

input deleteUserNewsletterInput {
  where: InputID
}

type deleteUserNewsletterPayload {
  userNewsletter: UserNewsletter
}

type Videos {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  video: UploadFile
  Review_Bioeffect: String
  video_name: String
  description: String
  published_at: DateTime
}

type VideosConnection {
  values: [Videos]
  groupBy: VideosGroupBy
  aggregate: VideosAggregator
}

type VideosAggregator {
  count: Int
  totalCount: Int
}

type VideosGroupBy {
  id: [VideosConnectionId]
  created_at: [VideosConnectionCreated_at]
  updated_at: [VideosConnectionUpdated_at]
  video: [VideosConnectionVideo]
  Review_Bioeffect: [VideosConnectionReview_Bioeffect]
  video_name: [VideosConnectionVideo_name]
  description: [VideosConnectionDescription]
  published_at: [VideosConnectionPublished_at]
}

type VideosConnectionId {
  key: ID
  connection: VideosConnection
}

type VideosConnectionCreated_at {
  key: DateTime
  connection: VideosConnection
}

type VideosConnectionUpdated_at {
  key: DateTime
  connection: VideosConnection
}

type VideosConnectionVideo {
  key: ID
  connection: VideosConnection
}

type VideosConnectionReview_Bioeffect {
  key: String
  connection: VideosConnection
}

type VideosConnectionVideo_name {
  key: String
  connection: VideosConnection
}

type VideosConnectionDescription {
  key: String
  connection: VideosConnection
}

type VideosConnectionPublished_at {
  key: DateTime
  connection: VideosConnection
}

input VideoInput {
  video: ID
  Review_Bioeffect: String
  video_name: String
  description: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVideoInput {
  video: ID
  Review_Bioeffect: String
  video_name: String
  description: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVideoInput {
  data: VideoInput
}

type createVideoPayload {
  video: Videos
}

input updateVideoInput {
  where: InputID
  data: editVideoInput
}

type updateVideoPayload {
  video: Videos
}

input deleteVideoInput {
  where: InputID
}

type deleteVideoPayload {
  video: Videos
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  regular_customer: Boolean
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
  regular_customer: [UsersPermissionsUserConnectionRegular_customer]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRegular_customer {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  images: [ID]
  regular_customer: Boolean
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  images: [ID]
  regular_customer: Boolean
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | Category | CategoryConnection | CategoryAggregator | CategoryGroupBy | CategoryConnectionId | CategoryConnectionCreated_at | CategoryConnectionUpdated_at | CategoryConnectionCategoryName | CategoryConnectionPublished_at | createCategoryPayload | updateCategoryPayload | deleteCategoryPayload | CollectionShop | CollectionShopConnection | CollectionShopAggregator | CollectionShopGroupBy | CollectionShopConnectionId | CollectionShopConnectionCreated_at | CollectionShopConnectionUpdated_at | CollectionShopConnectionHeader | CollectionShopConnectionTitle | CollectionShopConnectionUrl | CollectionShopConnectionImages | CollectionShopConnectionLink_text | CollectionShopConnectionPosition | CollectionShopConnectionPublished_at | createCollectionShopPayload | updateCollectionShopPayload | deleteCollectionShopPayload | ContactDetails | ContactDetailsConnection | ContactDetailsAggregator | ContactDetailsGroupBy | ContactDetailsConnectionId | ContactDetailsConnectionCreated_at | ContactDetailsConnectionUpdated_at | ContactDetailsConnectionEmail | ContactDetailsConnectionPhone_number | ContactDetailsConnectionPublished_at | createContactDetailPayload | updateContactDetailPayload | deleteContactDetailPayload | Contact | ContactConnection | ContactAggregator | ContactGroupBy | ContactConnectionId | ContactConnectionCreated_at | ContactConnectionUpdated_at | ContactConnectionTitle | ContactConnectionValue | ContactConnectionPublished_at | createContactPayload | updateContactPayload | deleteContactPayload | DiscountCodes | DiscountCodesConnection | DiscountCodesAggregator | DiscountCodesGroupBy | DiscountCodesConnectionId | DiscountCodesConnectionCreated_at | DiscountCodesConnectionUpdated_at | DiscountCodesConnectionName | DiscountCodesConnectionDescription | DiscountCodesConnectionStatus_voucher | DiscountCodesConnectionUnique_multiple | DiscountCodesConnectionMultiple_redemptions | DiscountCodesConnectionOne_redemption | DiscountCodesConnectionRedeem_until_usedup | DiscountCodesConnectionSingle_redemption | DiscountCodesConnectionMinimum_order_value | DiscountCodesConnectionValid_from_date_time | DiscountCodesConnectionValid_to_date_time | DiscountCodesConnectionCode_character_length | DiscountCodesConnectionAmount_discount | DiscountCodesConnectionType_of_discount | DiscountCodesConnectionPublished_at | createDiscountCodePayload | updateDiscountCodePayload | deleteDiscountCodePayload | Discount | updateDiscountPayload | deleteDiscountPayload | DpabStore | DpabStoreConnection | DpabStoreAggregator | DpabStoreGroupBy | DpabStoreConnectionId | DpabStoreConnectionCreated_at | DpabStoreConnectionUpdated_at | DpabStoreConnectionTitle | DpabStoreConnectionValue_1 | DpabStoreConnectionValue_2 | DpabStoreConnectionPublished_at | createDpabStorePayload | updateDpabStorePayload | deleteDpabStorePayload | FavoriteProduct | FavoriteProductConnection | FavoriteProductAggregator | FavoriteProductGroupBy | FavoriteProductConnectionId | FavoriteProductConnectionCreated_at | FavoriteProductConnectionUpdated_at | FavoriteProductConnectionUsers_permissions_user | FavoriteProductConnectionProduct | FavoriteProductConnectionPublished_at | createFavoriteProductPayload | updateFavoriteProductPayload | deleteFavoriteProductPayload | FourIcons | FourIconsConnection | FourIconsAggregator | FourIconsGroupBy | FourIconsConnectionId | FourIconsConnectionCreated_at | FourIconsConnectionUpdated_at | FourIconsConnectionHeader | FourIconsConnectionText | FourIconsConnectionSvg | FourIconsConnectionPublished_at | createFourIconPayload | updateFourIconPayload | deleteFourIconPayload | GiftWrap | GiftWrapConnection | GiftWrapAggregator | GiftWrapGroupBy | GiftWrapConnectionId | GiftWrapConnectionCreated_at | GiftWrapConnectionUpdated_at | GiftWrapConnectionPrice | GiftWrapConnectionName | GiftWrapConnectionText | GiftWrapConnectionSecure | GiftWrapConnectionPublished_at | createGiftWrapPayload | updateGiftWrapPayload | deleteGiftWrapPayload | Inspiration | InspirationConnection | InspirationAggregator | InspirationGroupBy | InspirationConnectionId | InspirationConnectionCreated_at | InspirationConnectionUpdated_at | InspirationConnectionHeader | InspirationConnectionTitle | InspirationConnectionText | InspirationConnectionButton_text | InspirationConnectionUrl | InspirationConnectionImages | InspirationConnectionImage_header | InspirationConnectionImage_title | InspirationConnectionPosition | InspirationConnectionPublished_at | createInspirationPayload | updateInspirationPayload | deleteInspirationPayload | MagazinPresentation | MagazinPresentationConnection | MagazinPresentationAggregator | MagazinPresentationGroupBy | MagazinPresentationConnectionId | MagazinPresentationConnectionCreated_at | MagazinPresentationConnectionUpdated_at | MagazinPresentationConnectionImages_1 | MagazinPresentationConnectionText_1 | MagazinPresentationConnectionText_2 | MagazinPresentationConnectionImages_2 | MagazinPresentationConnectionPosition | MagazinPresentationConnectionPublished_at | createMagazinPresentationPayload | updateMagazinPresentationPayload | deleteMagazinPresentationPayload | MainAccount | MainAccountConnection | MainAccountAggregator | MainAccountGroupBy | MainAccountConnectionId | MainAccountConnectionCreated_at | MainAccountConnectionUpdated_at | MainAccountConnectionAddresses | MainAccountConnectionUser_data | MainAccountConnectionOrders | MainAccountConnectionWishlist | MainAccountConnectionNewsletter | MainAccountConnectionMy_bookmarks | MainAccountConnectionPublished_at | createMainAccountPayload | updateMainAccountPayload | deleteMainAccountPayload | MeinKonto | MeinKontoConnection | MeinKontoAggregator | MeinKontoGroupBy | MeinKontoConnectionId | MeinKontoConnectionCreated_at | MeinKontoConnectionUpdated_at | MeinKontoConnectionTitle | MeinKontoConnectionPublished_at | createMeinKontoPayload | updateMeinKontoPayload | deleteMeinKontoPayload | MenuItem | MenuItemConnection | MenuItemAggregator | MenuItemGroupBy | MenuItemConnectionId | MenuItemConnectionCreated_at | MenuItemConnectionUpdated_at | MenuItemConnectionItem_name | MenuItemConnectionTitle | MenuItemConnectionImages | MenuItemConnectionUrl | MenuItemConnectionPosition | MenuItemConnectionPublished_at | createMenuItemPayload | updateMenuItemPayload | deleteMenuItemPayload | NewProductLimit | updateNewProductLimitPayload | deleteNewProductLimitPayload | NewsReport | NewsReportConnection | NewsReportAggregator | NewsReportGroupBy | NewsReportConnectionId | NewsReportConnectionCreated_at | NewsReportConnectionUpdated_at | NewsReportConnectionHeader | NewsReportConnectionTitle | NewsReportConnectionText | NewsReportConnectionUrl | NewsReportConnectionLink_text | NewsReportConnectionImages | NewsReportConnectionPosition | NewsReportConnectionPublished_at | createNewsReportPayload | updateNewsReportPayload | deleteNewsReportPayload | Newsletter | NewsletterConnection | NewsletterAggregator | NewsletterGroupBy | NewsletterConnectionId | NewsletterConnectionCreated_at | NewsletterConnectionUpdated_at | NewsletterConnectionSubject | NewsletterConnectionHTML_describe | NewsletterConnectionPublished_at | createNewsletterPayload | updateNewsletterPayload | deleteNewsletterPayload | PageHeader | PageHeaderConnection | PageHeaderAggregator | PageHeaderGroupBy | PageHeaderConnectionId | PageHeaderConnectionCreated_at | PageHeaderConnectionUpdated_at | PageHeaderConnectionDescribe_HTML_CSS | PageHeaderConnectionPosition | PageHeaderConnectionPublished_at | createPageHeaderPayload | updatePageHeaderPayload | deletePageHeaderPayload | PermanentDiscount | updatePermanentDiscountPayload | deletePermanentDiscountPayload | ProductWithLeftText | ProductWithLeftTextConnection | ProductWithLeftTextAggregator | ProductWithLeftTextGroupBy | ProductWithLeftTextConnectionId | ProductWithLeftTextConnectionCreated_at | ProductWithLeftTextConnectionUpdated_at | ProductWithLeftTextConnectionHeader | ProductWithLeftTextConnectionTitle | ProductWithLeftTextConnectionText | ProductWithLeftTextConnectionButton_text | ProductWithLeftTextConnectionUrl | ProductWithLeftTextConnectionPosition | ProductWithLeftTextConnectionPublished_at | createProductWithLeftTextPayload | updateProductWithLeftTextPayload | deleteProductWithLeftTextPayload | Products | ProductsConnection | ProductsAggregator | ProductsGroupBy | ProductsConnectionId | ProductsConnectionCreated_at | ProductsConnectionUpdated_at | ProductsConnectionPrice | ProductsConnectionClean_product | ProductsConnectionBrand | ProductsConnectionFor_sale_count | ProductsConnectionUnit | ProductsConnectionDiscount | ProductsConnectionType_test | ProductsConnectionCategory | ProductsConnectionSub_category | ProductsConnectionMenu_item | ProductsConnectionName | ProductsConnectionMagazin_presentation | ProductsConnectionKind | ProductsConnectionNew_Date_Limit | ProductsConnectionVideo | ProductsConnectionPublished_at | createProductPayload | updateProductPayload | deleteProductPayload | SectionUnderNavbar | SectionUnderNavbarConnection | SectionUnderNavbarAggregator | SectionUnderNavbarGroupBy | SectionUnderNavbarConnectionId | SectionUnderNavbarConnectionCreated_at | SectionUnderNavbarConnectionUpdated_at | SectionUnderNavbarConnectionHeader | SectionUnderNavbarConnectionTitle | SectionUnderNavbarConnectionButton_text | SectionUnderNavbarConnectionUrl | SectionUnderNavbarConnectionImages | SectionUnderNavbarConnectionPosition | SectionUnderNavbarConnectionPublished_at | createSectionUnderNavbarPayload | updateSectionUnderNavbarPayload | deleteSectionUnderNavbarPayload | ShopPageLargeText | ShopPageLargeTextConnection | ShopPageLargeTextAggregator | ShopPageLargeTextGroupBy | ShopPageLargeTextConnectionId | ShopPageLargeTextConnectionCreated_at | ShopPageLargeTextConnectionUpdated_at | ShopPageLargeTextConnectionHeader | ShopPageLargeTextConnectionText | ShopPageLargeTextConnectionPublished_at | createShopPageLargeTextPayload | updateShopPageLargeTextPayload | deleteShopPageLargeTextPayload | ShoppingBasketRecommendation | ShoppingBasketRecommendationConnection | ShoppingBasketRecommendationAggregator | ShoppingBasketRecommendationGroupBy | ShoppingBasketRecommendationConnectionId | ShoppingBasketRecommendationConnectionCreated_at | ShoppingBasketRecommendationConnectionUpdated_at | ShoppingBasketRecommendationConnectionTo | ShoppingBasketRecommendationConnectionFrom | ShoppingBasketRecommendationConnectionCurrent_shopping_basket_product_id | ShoppingBasketRecommendationConnectionPublished_at | createShoppingBasketRecommendationPayload | updateShoppingBasketRecommendationPayload | deleteShoppingBasketRecommendationPayload | ShoppingBasket | ShoppingBasketConnection | ShoppingBasketAggregator | ShoppingBasketGroupBy | ShoppingBasketConnectionId | ShoppingBasketConnectionCreated_at | ShoppingBasketConnectionUpdated_at | ShoppingBasketConnectionUsers_permissions_user | ShoppingBasketConnectionProduct | ShoppingBasketConnectionQuantity | ShoppingBasketConnectionGift_wrap | ShoppingBasketConnectionType_test | ShoppingBasketConnectionPublished_at | createShoppingBasketPayload | updateShoppingBasketPayload | deleteShoppingBasketPayload | StairSection | StairSectionConnection | StairSectionAggregator | StairSectionGroupBy | StairSectionConnectionId | StairSectionConnectionCreated_at | StairSectionConnectionUpdated_at | StairSectionConnectionHeader_1 | StairSectionConnectionText_1 | StairSectionConnectionImages_1 | StairSectionConnectionPosition | StairSectionConnectionHeader_2 | StairSectionConnectionText_2 | StairSectionConnectionHeader_3 | StairSectionConnectionText_3 | StairSectionConnectionPublished_at | createStairSectionPayload | updateStairSectionPayload | deleteStairSectionPayload | SubCategory | SubCategoryConnection | SubCategoryAggregator | SubCategoryGroupBy | SubCategoryConnectionId | SubCategoryConnectionCreated_at | SubCategoryConnectionUpdated_at | SubCategoryConnectionSubCategoryName | SubCategoryConnectionPublished_at | createSubCategoryPayload | updateSubCategoryPayload | deleteSubCategoryPayload | TypeTest | TypeTestConnection | TypeTestAggregator | TypeTestAggregatorSum | TypeTestAggregatorAvg | TypeTestAggregatorMin | TypeTestAggregatorMax | TypeTestGroupBy | TypeTestConnectionId | TypeTestConnectionCreated_at | TypeTestConnectionUpdated_at | TypeTestConnectionBrand | TypeTestConnectionPrice | TypeTestConnectionSize | TypeTestConnectionQuantity | TypeTestConnectionProduct | TypeTestConnectionImages | TypeTestConnectionPublished_at | createTypeTestPayload | updateTypeTestPayload | deleteTypeTestPayload | UserNewsletter | UserNewsletterConnection | UserNewsletterAggregator | UserNewsletterGroupBy | UserNewsletterConnectionId | UserNewsletterConnectionCreated_at | UserNewsletterConnectionUpdated_at | UserNewsletterConnectionFirst_name | UserNewsletterConnectionSurname | UserNewsletterConnectionGender | UserNewsletterConnectionEmail | UserNewsletterConnectionPublished_at | createUserNewsletterPayload | updateUserNewsletterPayload | deleteUserNewsletterPayload | Videos | VideosConnection | VideosAggregator | VideosGroupBy | VideosConnectionId | VideosConnectionCreated_at | VideosConnectionUpdated_at | VideosConnectionVideo | VideosConnectionReview_Bioeffect | VideosConnectionVideo_name | VideosConnectionDescription | VideosConnectionPublished_at | createVideoPayload | updateVideoPayload | deleteVideoPayload | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionRegular_customer | createUserPayload | updateUserPayload | deleteUserPayload

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  category(id: ID!, publicationState: PublicationState): Category
  categories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Category]
  categoriesConnection(sort: String, limit: Int, start: Int, where: JSON): CategoryConnection
  collectionShop(id: ID!, publicationState: PublicationState): CollectionShop
  collectionShops(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [CollectionShop]
  collectionShopsConnection(sort: String, limit: Int, start: Int, where: JSON): CollectionShopConnection
  contactDetail(id: ID!, publicationState: PublicationState): ContactDetails
  contactDetails(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ContactDetails]
  contactDetailsConnection(sort: String, limit: Int, start: Int, where: JSON): ContactDetailsConnection
  contact(id: ID!, publicationState: PublicationState): Contact
  contacts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Contact]
  contactsConnection(sort: String, limit: Int, start: Int, where: JSON): ContactConnection
  discountCode(id: ID!, publicationState: PublicationState): DiscountCodes
  discountCodes(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DiscountCodes]
  discountCodesConnection(sort: String, limit: Int, start: Int, where: JSON): DiscountCodesConnection
  discount(publicationState: PublicationState): Discount
  dpabStore(id: ID!, publicationState: PublicationState): DpabStore
  dpabStores(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DpabStore]
  dpabStoresConnection(sort: String, limit: Int, start: Int, where: JSON): DpabStoreConnection
  favoriteProduct(id: ID!, publicationState: PublicationState): FavoriteProduct
  favoriteProducts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [FavoriteProduct]
  favoriteProductsConnection(sort: String, limit: Int, start: Int, where: JSON): FavoriteProductConnection
  fourIcon(id: ID!, publicationState: PublicationState): FourIcons
  fourIcons(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [FourIcons]
  fourIconsConnection(sort: String, limit: Int, start: Int, where: JSON): FourIconsConnection
  giftWrap(id: ID!, publicationState: PublicationState): GiftWrap
  giftWraps(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [GiftWrap]
  giftWrapsConnection(sort: String, limit: Int, start: Int, where: JSON): GiftWrapConnection
  inspiration(id: ID!, publicationState: PublicationState): Inspiration
  inspirations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Inspiration]
  inspirationsConnection(sort: String, limit: Int, start: Int, where: JSON): InspirationConnection
  magazinPresentation(id: ID!, publicationState: PublicationState): MagazinPresentation
  magazinPresentations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MagazinPresentation]
  magazinPresentationsConnection(sort: String, limit: Int, start: Int, where: JSON): MagazinPresentationConnection
  mainAccount(id: ID!, publicationState: PublicationState): MainAccount
  mainAccounts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MainAccount]
  mainAccountsConnection(sort: String, limit: Int, start: Int, where: JSON): MainAccountConnection
  meinKonto(id: ID!, publicationState: PublicationState): MeinKonto
  meinKontos(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MeinKonto]
  meinKontosConnection(sort: String, limit: Int, start: Int, where: JSON): MeinKontoConnection
  menuItem(id: ID!, publicationState: PublicationState): MenuItem
  menuItems(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [MenuItem]
  menuItemsConnection(sort: String, limit: Int, start: Int, where: JSON): MenuItemConnection
  newProductLimit(publicationState: PublicationState): NewProductLimit
  newsReport(id: ID!, publicationState: PublicationState): NewsReport
  newsReports(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [NewsReport]
  newsReportsConnection(sort: String, limit: Int, start: Int, where: JSON): NewsReportConnection
  newsletter(id: ID!, publicationState: PublicationState): Newsletter
  newsletters(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Newsletter]
  newslettersConnection(sort: String, limit: Int, start: Int, where: JSON): NewsletterConnection
  pageHeader(id: ID!, publicationState: PublicationState): PageHeader
  pageHeaders(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [PageHeader]
  pageHeadersConnection(sort: String, limit: Int, start: Int, where: JSON): PageHeaderConnection
  permanentDiscount(publicationState: PublicationState): PermanentDiscount
  productWithLeftText(id: ID!, publicationState: PublicationState): ProductWithLeftText
  productWithLeftTexts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProductWithLeftText]
  productWithLeftTextsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductWithLeftTextConnection
  product(id: ID!, publicationState: PublicationState): Products
  products(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Products]
  productsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductsConnection
  sectionUnderNavbar(id: ID!, publicationState: PublicationState): SectionUnderNavbar
  sectionUnderNavbars(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [SectionUnderNavbar]
  sectionUnderNavbarsConnection(sort: String, limit: Int, start: Int, where: JSON): SectionUnderNavbarConnection
  shopPageLargeText(id: ID!, publicationState: PublicationState): ShopPageLargeText
  shopPageLargeTexts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShopPageLargeText]
  shopPageLargeTextsConnection(sort: String, limit: Int, start: Int, where: JSON): ShopPageLargeTextConnection
  shoppingBasketRecommendation(id: ID!, publicationState: PublicationState): ShoppingBasketRecommendation
  shoppingBasketRecommendations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShoppingBasketRecommendation]
  shoppingBasketRecommendationsConnection(sort: String, limit: Int, start: Int, where: JSON): ShoppingBasketRecommendationConnection
  shoppingBasket(id: ID!, publicationState: PublicationState): ShoppingBasket
  shoppingBaskets(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShoppingBasket]
  shoppingBasketsConnection(sort: String, limit: Int, start: Int, where: JSON): ShoppingBasketConnection
  stairSection(id: ID!, publicationState: PublicationState): StairSection
  stairSections(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [StairSection]
  stairSectionsConnection(sort: String, limit: Int, start: Int, where: JSON): StairSectionConnection
  subCategory(id: ID!, publicationState: PublicationState): SubCategory
  subCategories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [SubCategory]
  subCategoriesConnection(sort: String, limit: Int, start: Int, where: JSON): SubCategoryConnection
  typeTest(id: ID!, publicationState: PublicationState): TypeTest
  typeTests(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [TypeTest]
  typeTestsConnection(sort: String, limit: Int, start: Int, where: JSON): TypeTestConnection
  userNewsletter(id: ID!, publicationState: PublicationState): UserNewsletter
  userNewsletters(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UserNewsletter]
  userNewslettersConnection(sort: String, limit: Int, start: Int, where: JSON): UserNewsletterConnection
  video(id: ID!, publicationState: PublicationState): Videos
  videos(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Videos]
  videosConnection(sort: String, limit: Int, start: Int, where: JSON): VideosConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

type Mutation {
  createCategory(input: createCategoryInput): createCategoryPayload
  updateCategory(input: updateCategoryInput): updateCategoryPayload
  deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
  createCollectionShop(input: createCollectionShopInput): createCollectionShopPayload
  updateCollectionShop(input: updateCollectionShopInput): updateCollectionShopPayload
  deleteCollectionShop(input: deleteCollectionShopInput): deleteCollectionShopPayload
  createContactDetail(input: createContactDetailInput): createContactDetailPayload
  updateContactDetail(input: updateContactDetailInput): updateContactDetailPayload
  deleteContactDetail(input: deleteContactDetailInput): deleteContactDetailPayload
  createContact(input: createContactInput): createContactPayload
  updateContact(input: updateContactInput): updateContactPayload
  deleteContact(input: deleteContactInput): deleteContactPayload
  createDiscountCode(input: createDiscountCodeInput): createDiscountCodePayload
  updateDiscountCode(input: updateDiscountCodeInput): updateDiscountCodePayload
  deleteDiscountCode(input: deleteDiscountCodeInput): deleteDiscountCodePayload
  updateDiscount(input: updateDiscountInput): updateDiscountPayload
  deleteDiscount: deleteDiscountPayload
  createDpabStore(input: createDpabStoreInput): createDpabStorePayload
  updateDpabStore(input: updateDpabStoreInput): updateDpabStorePayload
  deleteDpabStore(input: deleteDpabStoreInput): deleteDpabStorePayload
  createFavoriteProduct(input: createFavoriteProductInput): createFavoriteProductPayload
  updateFavoriteProduct(input: updateFavoriteProductInput): updateFavoriteProductPayload
  deleteFavoriteProduct(input: deleteFavoriteProductInput): deleteFavoriteProductPayload
  createFourIcon(input: createFourIconInput): createFourIconPayload
  updateFourIcon(input: updateFourIconInput): updateFourIconPayload
  deleteFourIcon(input: deleteFourIconInput): deleteFourIconPayload
  createGiftWrap(input: createGiftWrapInput): createGiftWrapPayload
  updateGiftWrap(input: updateGiftWrapInput): updateGiftWrapPayload
  deleteGiftWrap(input: deleteGiftWrapInput): deleteGiftWrapPayload
  createInspiration(input: createInspirationInput): createInspirationPayload
  updateInspiration(input: updateInspirationInput): updateInspirationPayload
  deleteInspiration(input: deleteInspirationInput): deleteInspirationPayload
  createMagazinPresentation(input: createMagazinPresentationInput): createMagazinPresentationPayload
  updateMagazinPresentation(input: updateMagazinPresentationInput): updateMagazinPresentationPayload
  deleteMagazinPresentation(input: deleteMagazinPresentationInput): deleteMagazinPresentationPayload
  createMainAccount(input: createMainAccountInput): createMainAccountPayload
  updateMainAccount(input: updateMainAccountInput): updateMainAccountPayload
  deleteMainAccount(input: deleteMainAccountInput): deleteMainAccountPayload
  createMeinKonto(input: createMeinKontoInput): createMeinKontoPayload
  updateMeinKonto(input: updateMeinKontoInput): updateMeinKontoPayload
  deleteMeinKonto(input: deleteMeinKontoInput): deleteMeinKontoPayload
  createMenuItem(input: createMenuItemInput): createMenuItemPayload
  updateMenuItem(input: updateMenuItemInput): updateMenuItemPayload
  deleteMenuItem(input: deleteMenuItemInput): deleteMenuItemPayload
  updateNewProductLimit(input: updateNewProductLimitInput): updateNewProductLimitPayload
  deleteNewProductLimit: deleteNewProductLimitPayload
  createNewsReport(input: createNewsReportInput): createNewsReportPayload
  updateNewsReport(input: updateNewsReportInput): updateNewsReportPayload
  deleteNewsReport(input: deleteNewsReportInput): deleteNewsReportPayload
  createNewsletter(input: createNewsletterInput): createNewsletterPayload
  updateNewsletter(input: updateNewsletterInput): updateNewsletterPayload
  deleteNewsletter(input: deleteNewsletterInput): deleteNewsletterPayload
  createPageHeader(input: createPageHeaderInput): createPageHeaderPayload
  updatePageHeader(input: updatePageHeaderInput): updatePageHeaderPayload
  deletePageHeader(input: deletePageHeaderInput): deletePageHeaderPayload
  updatePermanentDiscount(input: updatePermanentDiscountInput): updatePermanentDiscountPayload
  deletePermanentDiscount: deletePermanentDiscountPayload
  createProductWithLeftText(input: createProductWithLeftTextInput): createProductWithLeftTextPayload
  updateProductWithLeftText(input: updateProductWithLeftTextInput): updateProductWithLeftTextPayload
  deleteProductWithLeftText(input: deleteProductWithLeftTextInput): deleteProductWithLeftTextPayload
  createProduct(input: createProductInput): createProductPayload
  updateProduct(input: updateProductInput): updateProductPayload
  deleteProduct(input: deleteProductInput): deleteProductPayload
  createSectionUnderNavbar(input: createSectionUnderNavbarInput): createSectionUnderNavbarPayload
  updateSectionUnderNavbar(input: updateSectionUnderNavbarInput): updateSectionUnderNavbarPayload
  deleteSectionUnderNavbar(input: deleteSectionUnderNavbarInput): deleteSectionUnderNavbarPayload
  createShopPageLargeText(input: createShopPageLargeTextInput): createShopPageLargeTextPayload
  updateShopPageLargeText(input: updateShopPageLargeTextInput): updateShopPageLargeTextPayload
  deleteShopPageLargeText(input: deleteShopPageLargeTextInput): deleteShopPageLargeTextPayload
  createShoppingBasketRecommendation(input: createShoppingBasketRecommendationInput): createShoppingBasketRecommendationPayload
  updateShoppingBasketRecommendation(input: updateShoppingBasketRecommendationInput): updateShoppingBasketRecommendationPayload
  deleteShoppingBasketRecommendation(input: deleteShoppingBasketRecommendationInput): deleteShoppingBasketRecommendationPayload
  createShoppingBasket(input: createShoppingBasketInput): createShoppingBasketPayload
  updateShoppingBasket(input: updateShoppingBasketInput): updateShoppingBasketPayload
  deleteShoppingBasket(input: deleteShoppingBasketInput): deleteShoppingBasketPayload
  createStairSection(input: createStairSectionInput): createStairSectionPayload
  updateStairSection(input: updateStairSectionInput): updateStairSectionPayload
  deleteStairSection(input: deleteStairSectionInput): deleteStairSectionPayload
  createSubCategory(input: createSubCategoryInput): createSubCategoryPayload
  updateSubCategory(input: updateSubCategoryInput): updateSubCategoryPayload
  deleteSubCategory(input: deleteSubCategoryInput): deleteSubCategoryPayload
  createTypeTest(input: createTypeTestInput): createTypeTestPayload
  updateTypeTest(input: updateTypeTestInput): updateTypeTestPayload
  deleteTypeTest(input: deleteTypeTestInput): deleteTypeTestPayload
  createUserNewsletter(input: createUserNewsletterInput): createUserNewsletterPayload
  updateUserNewsletter(input: updateUserNewsletterInput): updateUserNewsletterPayload
  deleteUserNewsletter(input: deleteUserNewsletterInput): deleteUserNewsletterPayload
  createVideo(input: createVideoInput): createVideoPayload
  updateVideo(input: updateVideoInput): updateVideoPayload
  deleteVideo(input: deleteVideoInput): deleteVideoPayload

  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload
